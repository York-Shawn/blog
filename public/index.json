[{"categories":["Documentation"],"content":"In this chapter, we gonna make basic module and public module. These module seldom associate with core business, their task is to connect different parts of app, and make app a closed loop. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:0:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#"},{"categories":["Documentation"],"content":"1. Standerlized ErrorCode ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#1-standerlized-errorcode"},{"categories":["Documentation"],"content":"1.1 common errcode predefine common errcode in pkg/errcode to guide users var ( Success = NewError(0, \"成功\") ServerError = NewError(10000000, \"服务内部错误\") InvalidParams = NewError(10000001, \"入参错误\") NotFound = NewError(10000002, \"找不到\") UnauthorizedAuthNotExist = NewError(10000003, \"鉴权失败，找不到对应的 AppKey 和 AppSecret\") UnauthorizedTokenError = NewError(10000004, \"鉴权失败，Token 错误\") UnauthorizedTokenTimeout = NewError(10000005, \"鉴权失败，Token 超时\") UnauthorizedTokenGenerate = NewError(10000006, \"鉴权失败，Token 生成失败\") TooManyRequests = NewError(10000007, \"请求过多\") ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#11-common-errcode"},{"categories":["Documentation"],"content":"1.2 error handler create errcode.go in pkg/errcode, write some public methods od error handling to standerlized our error output. errcode.go type Error struct { code int `json:\"code\"` msg string `json:\"msg\"` details []string `json:\"details\"` } var codes = map[int]string{} func NewError(code int, msg string) *Error { if _, ok := codes[code]; ok { panic(fmt.Sprintf(\"错误码 %d 已经存在，请更换一个\", code)) } codes[code] = msg return \u0026Error{code: code, msg: msg} } func (e *Error) Error() string { return fmt.Sprintf(\"错误码：%d, 错误信息:：%s\", e.Code(), e.Msg()) } func (e *Error) Code() int { return e.code } func (e *Error) Msg() string { return e.msg } func (e *Error) Msgf(args []interface{}) string { return fmt.Sprintf(e.msg, args...) } func (e *Error) Details() []string { return e.details } func (e *Error) WithDetails(details ...string) *Error { newError := *e newError.details = []string{} for _, d := range details { newError.details = append(newError.details, d) } return \u0026newError } func (e *Error) StatusCode() int { switch e.Code() { case Success.Code(): return http.StatusOK case ServerError.Code(): return http.StatusInternalServerError case InvalidParams.Code(): return http.StatusBadRequest case UnauthorizedAuthNotExist.Code(): fallthrough case UnauthorizedTokenError.Code(): fallthrough case UnauthorizedTokenGenerate.Code(): fallthrough case UnauthorizedTokenTimeout.Code(): return http.StatusUnauthorized case TooManyRequests.Code(): return http.StatusTooManyRequests } return http.StatusInternalServerError } in the common_code.go we use NewError method to create Error structure as the response towards error. codes is the carrier of global errcode. StatusCod method is used for StatusCode transformation of specific errcode, given a Error and match its Code to common error and return the matched one. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#12-error-handler"},{"categories":["Documentation"],"content":"1.2 error handler create errcode.go in pkg/errcode, write some public methods od error handling to standerlized our error output. errcode.go type Error struct { code int `json:\"code\"` msg string `json:\"msg\"` details []string `json:\"details\"` } var codes = map[int]string{} func NewError(code int, msg string) *Error { if _, ok := codes[code]; ok { panic(fmt.Sprintf(\"错误码 %d 已经存在，请更换一个\", code)) } codes[code] = msg return \u0026Error{code: code, msg: msg} } func (e *Error) Error() string { return fmt.Sprintf(\"错误码：%d, 错误信息:：%s\", e.Code(), e.Msg()) } func (e *Error) Code() int { return e.code } func (e *Error) Msg() string { return e.msg } func (e *Error) Msgf(args []interface{}) string { return fmt.Sprintf(e.msg, args...) } func (e *Error) Details() []string { return e.details } func (e *Error) WithDetails(details ...string) *Error { newError := *e newError.details = []string{} for _, d := range details { newError.details = append(newError.details, d) } return \u0026newError } func (e *Error) StatusCode() int { switch e.Code() { case Success.Code(): return http.StatusOK case ServerError.Code(): return http.StatusInternalServerError case InvalidParams.Code(): return http.StatusBadRequest case UnauthorizedAuthNotExist.Code(): fallthrough case UnauthorizedTokenError.Code(): fallthrough case UnauthorizedTokenGenerate.Code(): fallthrough case UnauthorizedTokenTimeout.Code(): return http.StatusUnauthorized case TooManyRequests.Code(): return http.StatusTooManyRequests } return http.StatusInternalServerError } in the common_code.go we use NewError method to create Error structure as the response towards error. codes is the carrier of global errcode. StatusCod method is used for StatusCode transformation of specific errcode, given a Error and match its Code to common error and return the matched one. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#errcodego"},{"categories":["Documentation"],"content":"2. Configuration Management use third party lib viper to manage conf go get -u github.com/spf13/viper ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#2-configuration-management"},{"categories":["Documentation"],"content":"2.1 configuration file create config.yaml in configs configs.yaml Server:RunMode:debugHttpPort:8080ReadTimeout:60WriteTimeout:60App:DefaultPageSize:10MaxPageSize:100LogSavePath:storage/logsLogFileName:appLogFileExt:.logDatabase:DBType:mysqlUsername:root # your own db usernamePassword:rootroot # your own db passwdHost:127.0.0.1:3306DBName:blog_serviceTablePrefix:blog_Charset:utf8ParseTime:TrueMaxIdleConns:10MaxOpenConns:30 in the configuration, we set the default settings for: Server: server conf, gin’s RunMode, default HTTP listening port, maximum read and write time APP: Application conf, default page size, maximum page size and default log save path Database: Database conf, required parameters of connecting to db instance ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#21-configuration-file"},{"categories":["Documentation"],"content":"2.1 configuration file create config.yaml in configs configs.yaml Server:RunMode:debugHttpPort:8080ReadTimeout:60WriteTimeout:60App:DefaultPageSize:10MaxPageSize:100LogSavePath:storage/logsLogFileName:appLogFileExt:.logDatabase:DBType:mysqlUsername:root # your own db usernamePassword:rootroot # your own db passwdHost:127.0.0.1:3306DBName:blog_serviceTablePrefix:blog_Charset:utf8ParseTime:TrueMaxIdleConns:10MaxOpenConns:30 in the configuration, we set the default settings for: Server: server conf, gin’s RunMode, default HTTP listening port, maximum read and write time APP: Application conf, default page size, maximum page size and default log save path Database: Database conf, required parameters of connecting to db instance ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#configsyaml"},{"categories":["Documentation"],"content":"3. component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#3-component"},{"categories":["Documentation"],"content":"3. component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo"},{"categories":["Documentation"],"content":"3. component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#sectiongo"},{"categories":["Documentation"],"content":"3.1 package gloabl variable To connect the conf and app, we should create global variable for us to use them. setting.go in global/ setting.go var ( ServerSetting *setting.ServerSettingS AppSetting *setting.AppSettingS DatabaseSetting *setting.DatabaseSettingS ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#31-package-gloabl-variable"},{"categories":["Documentation"],"content":"3.1 package gloabl variable To connect the conf and app, we should create global variable for us to use them. setting.go in global/ setting.go var ( ServerSetting *setting.ServerSettingS AppSetting *setting.AppSettingS DatabaseSetting *setting.DatabaseSettingS ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo-1"},{"categories":["Documentation"],"content":"3.2 initialize reading conf back to main.go main.go func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } } func main() {...} func setupSetting() error { setting, err := setting.NewSetting() if err != nil { return err } err = setting.ReadSection(\"Server\", \u0026global.ServerSetting) if err != nil { return err } err = setting.ReadSection(\"App\", \u0026global.AppSetting) if err != nil { return err } err = setting.ReadSection(\"Database\", \u0026global.DatabaseSetting) if err != nil { return err } global.ServerSetting.ReadTimeout *= time.Second global.ServerSetting.WriteTimeout *= time.Second return nil } init is used for initialize process in app, and is run automatically. Order is : init global variable =\u003e init method =\u003e main method ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#32-initialize-reading-conf"},{"categories":["Documentation"],"content":"3.2 initialize reading conf back to main.go main.go func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } } func main() {...} func setupSetting() error { setting, err := setting.NewSetting() if err != nil { return err } err = setting.ReadSection(\"Server\", \u0026global.ServerSetting) if err != nil { return err } err = setting.ReadSection(\"App\", \u0026global.AppSetting) if err != nil { return err } err = setting.ReadSection(\"Database\", \u0026global.DatabaseSetting) if err != nil { return err } global.ServerSetting.ReadTimeout *= time.Second global.ServerSetting.WriteTimeout *= time.Second return nil } init is used for initialize process in app, and is run automatically. Order is : init global variable = init method = main method ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#maingo"},{"categories":["Documentation"],"content":"3.3 modify server conf all we need to do is to set the conf and RunMode of gin in main.go func main() { gin.SetMode(global.ServerSetting.RunMode) router := routers.NewRouter() s := \u0026http.Server{ Addr: \":\" + global.ServerSetting.HttpPort, Handler: router, ReadTimeout: global.ServerSetting.ReadTimeout, WriteTimeout: global.ServerSetting.WriteTimeout, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#33-modify-server-conf"},{"categories":["Documentation"],"content":"4. DataBase Connection use third party lib gorm go get -u github.com/jinzhu/gorm ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#4-database-connection"},{"categories":["Documentation"],"content":"4.1 component add NewDBEngine method to model.go under internal/model/ model.go type Model struct {...} func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { db, err := gorm.Open(databaseSetting.DBType, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=%s\u0026parseTime=%t\u0026loc=Local\", databaseSetting.UserName, databaseSetting.Password, databaseSetting.Host, databaseSetting.DBName, databaseSetting.Charset, databaseSetting.ParseTime, )) if err != nil { return nil, err } if global.ServerSetting.RunMode == \"debug\" { db.LogMode(true) } db.SingularTable(true) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } NewDBEngine create a DB instance, and add the import of gorm and initialize MySQL driver lib github.com/jinzhu/gorm/dialects/mysql ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#41-component"},{"categories":["Documentation"],"content":"4.1 component add NewDBEngine method to model.go under internal/model/ model.go type Model struct {...} func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { db, err := gorm.Open(databaseSetting.DBType, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=%s\u0026parseTime=%t\u0026loc=Local\", databaseSetting.UserName, databaseSetting.Password, databaseSetting.Host, databaseSetting.DBName, databaseSetting.Charset, databaseSetting.ParseTime, )) if err != nil { return nil, err } if global.ServerSetting.RunMode == \"debug\" { db.LogMode(true) } db.SingularTable(true) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } NewDBEngine create a DB instance, and add the import of gorm and initialize MySQL driver lib github.com/jinzhu/gorm/dialects/mysql ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#modelgo"},{"categories":["Documentation"],"content":"4.2 package global variable create db.go in global db.go var ( DBEngine *gorm.DB ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#42-package-global-variable"},{"categories":["Documentation"],"content":"4.2 package global variable create db.go in global db.go var ( DBEngine *gorm.DB ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#dbgo"},{"categories":["Documentation"],"content":"4.3 initialization add method setupDBEngine to main.go main.go func init() { ... err = setupDBEngine() if err != nil { log.Fatalf(\"init.setupDBEngine err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error {...} func setupDBEngine() error { var err error global.DBEngine, err = model.NewDBEngine(global.DatabaseSetting) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#43-initialization"},{"categories":["Documentation"],"content":"4.3 initialization add method setupDBEngine to main.go main.go func init() { ... err = setupDBEngine() if err != nil { log.Fatalf(\"init.setupDBEngine err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error {...} func setupDBEngine() error { var err error global.DBEngine, err = model.NewDBEngine(global.DatabaseSetting) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#maingo-1"},{"categories":["Documentation"],"content":"5. Log go get -u gopkg.in/natefinch/lumberjack.v2 ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#5-log"},{"categories":["Documentation"],"content":"5.1 log classification create logger.go in pkg/logger/ logger.go type Level int8 type Fields map[string]interface{} const ( LevelDebug Level = iota LevelInfo LevelWarn LevelError LevelFatal LevelPanic ) func (l Level) String() string { switch l { case LevelDebug: return \"debug\" case LevelInfo: return \"info\" case LevelWarn: return \"warn\" case LevelError: return \"error\" case LevelFatal: return \"fatal\" case LevelPanic: return \"panic\" } return \"\" } We predefine the specific types of Level and Fields in app log, and categorize into Debug, Info, Warn, Error, Fatal, Panic. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#51-log-classification"},{"categories":["Documentation"],"content":"5.1 log classification create logger.go in pkg/logger/ logger.go type Level int8 type Fields map[string]interface{} const ( LevelDebug Level = iota LevelInfo LevelWarn LevelError LevelFatal LevelPanic ) func (l Level) String() string { switch l { case LevelDebug: return \"debug\" case LevelInfo: return \"info\" case LevelWarn: return \"warn\" case LevelError: return \"error\" case LevelFatal: return \"fatal\" case LevelPanic: return \"panic\" } return \"\" } We predefine the specific types of Level and Fields in app log, and categorize into Debug, Info, Warn, Error, Fatal, Panic. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo"},{"categories":["Documentation"],"content":"5.2 log standardization After categorize method, we shall work on methods for initialization of instance and standardized parameter binding logger.go type Logger struct { newLogger *log.Logger ctx context.Context fields Fields callers []string } func NewLogger(w io.Writer, prefix string, flag int) *Logger { l := log.New(w, prefix, flag) return \u0026Logger{newLogger: l} } func (l *Logger) clone() *Logger { nl := *l return \u0026nl } func (l *Logger) WithFields(f Fields) *Logger { ll := l.clone() if ll.fields == nil { ll.fields = make(Fields) } for k, v := range f { ll.fields[k] = v } return ll } func (l *Logger) WithContext(ctx context.Context) *Logger { ll := l.clone() ll.ctx = ctx return ll } func (l *Logger) WithCaller(skip int) *Logger { ll := l.clone() pc, file, line, ok := runtime.Caller(skip) if ok { f := runtime.FuncForPC(pc) ll.callers = []string{fmt.Sprintf(\"%s: %d %s\", file, line, f.Name())} } return ll } func (l *Logger) WithCallersFrames() *Logger { maxCallerDepth := 25 minCallerDepth := 1 callers := []string{} pcs := make([]uintptr, maxCallerDepth) depth := runtime.Callers(minCallerDepth, pcs) frames := runtime.CallersFrames(pcs[:depth]) for frame, more := frames.Next(); more; frame, more = frames.Next() { callers = append(callers, fmt.Sprintf(\"%s: %d %s\", frame.File, frame.Line, frame.Function)) if !more { break } } ll := l.clone() ll.callers = callers return ll } WithLevel: Set log level WithFields: Set log public fields WithContext: Set log context attribute WithCaller: Set one caller’s information WithCallerFrames: Set all caller’s information ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#52-log-standardization"},{"categories":["Documentation"],"content":"5.2 log standardization After categorize method, we shall work on methods for initialization of instance and standardized parameter binding logger.go type Logger struct { newLogger *log.Logger ctx context.Context fields Fields callers []string } func NewLogger(w io.Writer, prefix string, flag int) *Logger { l := log.New(w, prefix, flag) return \u0026Logger{newLogger: l} } func (l *Logger) clone() *Logger { nl := *l return \u0026nl } func (l *Logger) WithFields(f Fields) *Logger { ll := l.clone() if ll.fields == nil { ll.fields = make(Fields) } for k, v := range f { ll.fields[k] = v } return ll } func (l *Logger) WithContext(ctx context.Context) *Logger { ll := l.clone() ll.ctx = ctx return ll } func (l *Logger) WithCaller(skip int) *Logger { ll := l.clone() pc, file, line, ok := runtime.Caller(skip) if ok { f := runtime.FuncForPC(pc) ll.callers = []string{fmt.Sprintf(\"%s: %d %s\", file, line, f.Name())} } return ll } func (l *Logger) WithCallersFrames() *Logger { maxCallerDepth := 25 minCallerDepth := 1 callers := []string{} pcs := make([]uintptr, maxCallerDepth) depth := runtime.Callers(minCallerDepth, pcs) frames := runtime.CallersFrames(pcs[:depth]) for frame, more := frames.Next(); more; frame, more = frames.Next() { callers = append(callers, fmt.Sprintf(\"%s: %d %s\", frame.File, frame.Line, frame.Function)) if !more { break } } ll := l.clone() ll.callers = callers return ll } WithLevel: Set log level WithFields: Set log public fields WithContext: Set log context attribute WithCaller: Set one caller’s information WithCallerFrames: Set all caller’s information ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-1"},{"categories":["Documentation"],"content":"5.3 log formatting \u0026 output logger.go func (l *Logger) JSONFormat(level Level, message string) map[string]interface{} { data := make(Fields, len(l.fields)+4) data[\"level\"] = level.String() data[\"time\"] = time.Now().Local().UnixNano() data[\"message\"] = message data[\"callers\"] = l.callers if len(l.fields) \u003e 0 { for k, v := range l.fields { if _, ok := data[k]; !ok { data[k] = v } } } return data } func (l *Logger) Output(level Level, message string) { body, _ := json.Marshal(l.JSONFormat(level, message)) content := string(body) switch level { case LevelDebug: l.newLogger.Print(content) case LevelInfo: l.newLogger.Print(content) case LevelWarn: l.newLogger.Print(content) case LevelError: l.newLogger.Print(content) case LevelFatal: l.newLogger.Fatal(content) case LevelPanic: l.newLogger.Panic(content) } } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#53-log-formatting--output"},{"categories":["Documentation"],"content":"5.3 log formatting \u0026 output logger.go func (l *Logger) JSONFormat(level Level, message string) map[string]interface{} { data := make(Fields, len(l.fields)+4) data[\"level\"] = level.String() data[\"time\"] = time.Now().Local().UnixNano() data[\"message\"] = message data[\"callers\"] = l.callers if len(l.fields) 0 { for k, v := range l.fields { if _, ok := data[k]; !ok { data[k] = v } } } return data } func (l *Logger) Output(level Level, message string) { body, _ := json.Marshal(l.JSONFormat(level, message)) content := string(body) switch level { case LevelDebug: l.newLogger.Print(content) case LevelInfo: l.newLogger.Print(content) case LevelWarn: l.newLogger.Print(content) case LevelError: l.newLogger.Print(content) case LevelFatal: l.newLogger.Fatal(content) case LevelPanic: l.newLogger.Panic(content) } } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-2"},{"categories":["Documentation"],"content":"5.4 log classified output logger.go func (l *Logger) Info(v ...interface{}) { l.Output(LevelInfo, fmt.Sprint(v...)) } func (l *Logger) Infof(format string, v ...interface{}) { l.Output(LevelInfo, fmt.Sprintf(format, v...)) } func (l *Logger) Fatal(v ...interface{}) { l.Output(LevelFatal, fmt.Sprint(v...)) } func (l *Logger) Fatalf(format string, v ...interface{}) { l.Output(LevelFatal, fmt.Sprintf(format, v...)) } ... code above just shows info and Fatal output, other level code is no difference but the name and Withlevel. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:4","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#54-log-classified-output"},{"categories":["Documentation"],"content":"5.4 log classified output logger.go func (l *Logger) Info(v ...interface{}) { l.Output(LevelInfo, fmt.Sprint(v...)) } func (l *Logger) Infof(format string, v ...interface{}) { l.Output(LevelInfo, fmt.Sprintf(format, v...)) } func (l *Logger) Fatal(v ...interface{}) { l.Output(LevelFatal, fmt.Sprint(v...)) } func (l *Logger) Fatalf(format string, v ...interface{}) { l.Output(LevelFatal, fmt.Sprintf(format, v...)) } ... code above just shows info and Fatal output, other level code is no difference but the name and Withlevel. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:4","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-3"},{"categories":["Documentation"],"content":"5.5 package global variable after we finish the logger, we need to define a Logger object for our app to use. So, we open the global/setting.go file, add following contents. setting.go var ( ... Logger *logger.Logger ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:5","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#55-package-global-variable"},{"categories":["Documentation"],"content":"5.5 package global variable after we finish the logger, we need to define a Logger object for our app to use. So, we open the global/setting.go file, add following contents. setting.go var ( ... Logger *logger.Logger ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:5","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo-2"},{"categories":["Documentation"],"content":"5.6 initialization next, we should modify the main.go in the root directory, add on initialization for the Logger object we just defined func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } err = setupLogger() if err != nil { log.Fatalf(\"init.setupLogger err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error { global.Logger = logger.NewLogger(\u0026lumberjack.Logger{ Filename: global.AppSetting.LogSavePath + \"/\" + global.AppSetting.LogFileName + global.AppSetting.LogFileExt, MaxSize: 600, MaxAge: 10, LocalTime: true, }, \"\", log.LstdFlags).WithCaller(2) return nil } we add logger component through this file, and initialize the global variable Logger inside method setupLogger. Being aware that we use lumberjack as logger’s io.writer. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:6","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#56-initialization"},{"categories":["Documentation"],"content":"In this chapter, we majorly deal with project structure, interface, router. ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:0:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#"},{"categories":["Documentation"],"content":"1. Structure blog-service ├── configs ├── docs ├── global ├── internal │ ├── dao │ ├── middleware │ ├── model │ ├── routers │ └── service ├── pkg ├── storage ├── scripts └── third_party ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:1:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#1-structure"},{"categories":["Documentation"],"content":"2. Model The attributes of objects have in common should create an individual model to store . ├── internal/ │ └── model/ │ ├──model.go │ ├──tag.go │ ├──article.go │ └──article_tag.go and in each table model should contain the *Model tag.go type Tag struct { *Model Name string `json:\"name\"` State uint8 `json:\"state\"` } func (t Tag) TableName() string { return \"blog_tag\" } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#2-model"},{"categories":["Documentation"],"content":"2. Model The attributes of objects have in common should create an individual model to store . ├── internal/ │ └── model/ │ ├──model.go │ ├──tag.go │ ├──article.go │ └──article_tag.go and in each table model should contain the *Model tag.go type Tag struct { *Model Name string `json:\"name\"` State uint8 `json:\"state\"` } func (t Tag) TableName() string { return \"blog_tag\" } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#taggo"},{"categories":["Documentation"],"content":"3. Router ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#3-router"},{"categories":["Documentation"],"content":"3.1 router management decide the business api and declare the create method in internal/routers router.go func NewRouter() *gin.Engine { r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) apiv1 := r.Group(\"/api/v1\") { apiv1.POST(\"/tags\") apiv1.DELETE(\"/tags/:id\") apiv1.PUT(\"/tags/:id\") apiv1.PATCH(\"/tags/:id/state\") apiv1.GET(\"/tags\") apiv1.POST(\"/articles\") apiv1.DELETE(\"/articles/:id\") apiv1.PUT(\"/articles/:id\") apiv1.PATCH(\"/articles/:id/state\") apiv1.GET(\"/articles/:id\") apiv1.GET(\"/articles\") } return r } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#31-router-management"},{"categories":["Documentation"],"content":"3.2 Router handler api handler should be stored inside the internal/routers/api, dir name is the api’s version tag.go type Tag struct {} func NewTag() Tag { return Tag{} } func (t Tag) Get(c *gin.Context) {} func (t Tag) List(c *gin.Context) {} func (t Tag) Create(c *gin.Context) {} func (t Tag) Update(c *gin.Context) {} func (t Tag) Delete(c *gin.Context) {} ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#32-router-handler"},{"categories":["Documentation"],"content":"3.2 Router handler api handler should be stored inside the internal/routers/api, dir name is the api’s version tag.go type Tag struct {} func NewTag() Tag { return Tag{} } func (t Tag) Get(c *gin.Context) {} func (t Tag) List(c *gin.Context) {} func (t Tag) Create(c *gin.Context) {} func (t Tag) Update(c *gin.Context) {} func (t Tag) Delete(c *gin.Context) {} ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#taggo-1"},{"categories":["Documentation"],"content":"3.3 Boot access modify main.go, set parameters like TCP Endpoint, Readtime of http.Server main.go func main() { router := routers.NewRouter() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#33-boot-access"},{"categories":["Documentation"],"content":"3.3 Boot access modify main.go, set parameters like TCP Endpoint, Readtime of http.Server main.go func main() { router := routers.NewRouter() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#maingo"},{"categories":["Problem-Set"],"content":"1. ssh can’t connect to github (Sovled) Description: error kex_exchange_identification: Connection closed by remote host poped up when pushing to github. Got the same error message by running ssh -T git@github.com Solution: Use another VPN ","date":"2020-10-17","objectID":"/posts/problem-set/git/:1:0","series":null,"tags":["Git"],"title":"Git Problem Set","uri":"/posts/problem-set/git/#1-ssh-cant-connect-to-github-sovled"},{"categories":["Problem-Set"],"content":"2. fast-forward when pushing to remote (Solved) Solution: merge or fetch before push. Tip git push -f ... also works, but the repercussion might be irreversible and perilous ","date":"2020-10-17","objectID":"/posts/problem-set/git/:2:0","series":null,"tags":["Git"],"title":"Git Problem Set","uri":"/posts/problem-set/git/#2-fast-forward-when-pushing-to-remote-solved"},{"categories":["Problem-Set"],"content":"1.make command execute correctly, but the site can’t be reached for some reasons.（Solved） Description: By using telnet command, we can know certain port’s status. As a result, the 1313 port of wsl is running by hugo, but that of windows is closed. Apparently, solve the disconnection between wsl and windows gonna handle this problem. ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:1:0","series":null,"tags":["Linux","WSL"],"title":"WSL2(Windows Subsystem for Linux) Problem Set","uri":"/posts/problem-set/wsl/#1_make_-command-execute-correctly-but-the-site-cant-be-reached-for-some-reasonssolved"},{"categories":["Problem-Set"],"content":"ref： https://logi.im/script/achieving-access-to-files-and-resources-on-the-network-between-win10-and-wsl2.html https://www.cnblogs.com/hapjin/p/5367429.html For programs listen to 0.0.0.0 in wsl2, win10 can be accessed directly through localhost:port. Therefore we have to set bind address equal to 0.0.0.0 on hugo hugo server --bind=0.0.0.0 --port=1313 --minify --theme book Reason: The default address of localhost is Loopback address 127.0.0.1. It can only be accessed by local machine. So if we want to access wsl2 address from other consoles, we have to replace localhost in /etc/hosts. By adding new rule to hugo Makefile, type make win to create local blog on wsl2 that can be accessed on other machines wsl win windows: hugo server --bind=0.0.0.0 --port=1313 --minify --theme book ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:1:1","series":null,"tags":["Linux","WSL"],"title":"WSL2(Windows Subsystem for Linux) Problem Set","uri":"/posts/problem-set/wsl/#ref"},{"categories":["Problem-Set"],"content":"2.Port depolyed at 0:0:0:0 can’t be accessed from Windows. (Solved) Description: Almost the same with #problem 1, but Spring is running at 0:0:0:0. Spring-boot’s port can’t be browsed through Windows browser. ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:2:0","series":null,"tags":["Linux","WSL"],"title":"WSL2(Windows Subsystem for Linux) Problem Set","uri":"/posts/problem-set/wsl/#2port-depolyed-at-0000-cant-be-accessed-from-windows-solved"},{"categories":["Problem-Set"],"content":"ref: https://github.com/microsoft/WSL/discussions/2471 Using wsl --shutdown solved this problem, and we can also handle this by replacing localhost into the ip address of etho from ip addr(for some unknown reasons, the speed is way faster than using localhost) ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:2:1","series":null,"tags":["Linux","WSL"],"title":"WSL2(Windows Subsystem for Linux) Problem Set","uri":"/posts/problem-set/wsl/#ref-1"},{"categories":["Problem-Set"],"content":"3.The connection from Windows to MySQL in WSL2 failed(Solved) Description: Connect to MySQL by setting ip as localhost(already set the bind_address=0.0.0.0), but it ended up failure. ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:3:0","series":null,"tags":["Linux","WSL"],"title":"WSL2(Windows Subsystem for Linux) Problem Set","uri":"/posts/problem-set/wsl/#3the-connection-from-windows-to-mysql-in-wsl2-failedsolved"},{"categories":["Problem-Set"],"content":"ref: https://github.com/microsoft/WSL/issues/4150 https://stackoverflow.com/questions/61002681/connecting-to-wsl2-server-via-local-network It seems like Ubuntu host is virtually connected to windows host, and it’s netted by the Windows computer. To change that, we gonna forward the wsl2 port to windows, by using netsh interface portproxy add v4tov4 listenport=\u003cport-to-listen\u003e listenaddress=0.0.0.0 connectport=\u003cport-to-forward\u003e connectaddress=\u003cforward-to-this-IP-address\u003e Since then, there’s another problem as the ip address of wsl2 is dynamic, it will change as you reboot. To improve this method, we should run a script every time we start our computer that does: Get Ip Address of WSL2 machine Remove previous port forwarding rules Add port Forwarding rules Remove previously added firewall rules Add new Firewall Rules $remoteport = bash.exe -c \"ifconfig eth0 | grep 'inet '\" $found = $remoteport -match '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'; if( $found ){ $remoteport = $matches[0]; } else{ echo \"The Script Exited, the ip address of WSL 2 cannot be found\"; exit; } #[Ports] #All the ports you want to forward separated by coma $ports=@(80,443,10000,3000,5000); #[Static ip] #You can change the addr to your ip config to listen to a specific address $addr='0.0.0.0'; $ports_a = $ports -join \",\"; #Remove Firewall Exception Rules iex \"Remove-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' \"; #adding Exception Rules for inbound and outbound Rules iex \"New-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' -Direction Outbound -LocalPort $ports_a -Action Allow -Protocol TCP\"; iex \"New-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' -Direction Inbound -LocalPort $ports_a -Action Allow -Protocol TCP\"; for( $i = 0; $i -lt $ports.length; $i++ ){ $port = $ports[$i]; iex \"netsh interface portproxy delete v4tov4 listenport=$port listenaddress=$addr\"; iex \"netsh interface portproxy add v4tov4 listenport=$port listenaddress=$addr connectport=$port connectaddress=$remoteport\"; } The script must run under highest privilege. Use task scheduler to automatically start powershell and add argument as -ExecutionPolicy Bypass c:\\scripts\\wslbridge.ps1. Tip Navicat should change the ip to 127.0.0.1 instead of localhost. ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:3:1","series":null,"tags":["Linux","WSL"],"title":"WSL2(Windows Subsystem for Linux) Problem Set","uri":"/posts/problem-set/wsl/#ref-2"},{"categories":null,"content":"Who Am I My name is Aya, half weeb and half engineer. Hobby: Music, Food, ACGN Favorite Music: J-Pop, Rock, Jazz, Blues Favorite Band/Musician: ヨルシカ Favorite Anime: 天元突破グレンラガン Currently learning guitar🎸(Electric) Tele, Strat Guy If I was allowed to use only 2 brand’s guitars, it would be Fender and ESP Vocaloid, IdolM@aster, Touhou Mostly Listened Bands/Group: Hitorie, Zutomayo, ヨルシカ, Yoasobi, One Ok Rock, Guns N' Roses, BUMP OF CHICKEN, [Alexandros], Official髭男dism, TUYU Mostly Listened Musician: 美波, 愛繆, 宇多田ヒカル, Bruno Mars ","date":"2019-08-02","objectID":"/about/:1:0","series":null,"tags":null,"title":"About me","uri":"/about/#who-am-i"},{"categories":null,"content":"Skill Backend Development(Golang/JAVA) DevOps(what!?) Frontend Development(copy and paste stuff) FPS Player(call me Lil Simple) ","date":"2019-08-02","objectID":"/about/:2:0","series":null,"tags":null,"title":"About me","uri":"/about/#skill"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]