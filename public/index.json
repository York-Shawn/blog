[{"categories":["Documentation"],"content":"In this chapter, we gonna make basic module and public module. These module seldom associate with core business, their task is to connect different parts of app, and make app a closed loop. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:0:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#"},{"categories":["Documentation"],"content":"Standerlized ErrorCode ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#standerlized-errorcode"},{"categories":["Documentation"],"content":"common errcode predefine common errcode in pkg/errcode to guide users var ( Success = NewError(0, \"成功\") ServerError = NewError(10000000, \"服务内部错误\") InvalidParams = NewError(10000001, \"入参错误\") NotFound = NewError(10000002, \"找不到\") UnauthorizedAuthNotExist = NewError(10000003, \"鉴权失败，找不到对应的 AppKey 和 AppSecret\") UnauthorizedTokenError = NewError(10000004, \"鉴权失败，Token 错误\") UnauthorizedTokenTimeout = NewError(10000005, \"鉴权失败，Token 超时\") UnauthorizedTokenGenerate = NewError(10000006, \"鉴权失败，Token 生成失败\") TooManyRequests = NewError(10000007, \"请求过多\") ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#common-errcode"},{"categories":["Documentation"],"content":"error handler create errcode.go in pkg/errcode, write some public methods od error handling to standerlized our error output. errcode.go type Error struct { code int `json:\"code\"` msg string `json:\"msg\"` details []string `json:\"details\"` } var codes = map[int]string{} func NewError(code int, msg string) *Error { if _, ok := codes[code]; ok { panic(fmt.Sprintf(\"错误码 %d 已经存在，请更换一个\", code)) } codes[code] = msg return \u0026Error{code: code, msg: msg} } func (e *Error) Error() string { return fmt.Sprintf(\"错误码：%d, 错误信息:：%s\", e.Code(), e.Msg()) } func (e *Error) Code() int { return e.code } func (e *Error) Msg() string { return e.msg } func (e *Error) Msgf(args []interface{}) string { return fmt.Sprintf(e.msg, args...) } func (e *Error) Details() []string { return e.details } func (e *Error) WithDetails(details ...string) *Error { newError := *e newError.details = []string{} for _, d := range details { newError.details = append(newError.details, d) } return \u0026newError } func (e *Error) StatusCode() int { switch e.Code() { case Success.Code(): return http.StatusOK case ServerError.Code(): return http.StatusInternalServerError case InvalidParams.Code(): return http.StatusBadRequest case UnauthorizedAuthNotExist.Code(): fallthrough case UnauthorizedTokenError.Code(): fallthrough case UnauthorizedTokenGenerate.Code(): fallthrough case UnauthorizedTokenTimeout.Code(): return http.StatusUnauthorized case TooManyRequests.Code(): return http.StatusTooManyRequests } return http.StatusInternalServerError } in the common_code.go we use NewError method to create Error structure as the response towards error. codes is the carrier of global errcode. StatusCod method is used for StatusCode transformation of specific errcode, given a Error and match its Code to common error and return the matched one. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#error-handler"},{"categories":["Documentation"],"content":"error handler create errcode.go in pkg/errcode, write some public methods od error handling to standerlized our error output. errcode.go type Error struct { code int `json:\"code\"` msg string `json:\"msg\"` details []string `json:\"details\"` } var codes = map[int]string{} func NewError(code int, msg string) *Error { if _, ok := codes[code]; ok { panic(fmt.Sprintf(\"错误码 %d 已经存在，请更换一个\", code)) } codes[code] = msg return \u0026Error{code: code, msg: msg} } func (e *Error) Error() string { return fmt.Sprintf(\"错误码：%d, 错误信息:：%s\", e.Code(), e.Msg()) } func (e *Error) Code() int { return e.code } func (e *Error) Msg() string { return e.msg } func (e *Error) Msgf(args []interface{}) string { return fmt.Sprintf(e.msg, args...) } func (e *Error) Details() []string { return e.details } func (e *Error) WithDetails(details ...string) *Error { newError := *e newError.details = []string{} for _, d := range details { newError.details = append(newError.details, d) } return \u0026newError } func (e *Error) StatusCode() int { switch e.Code() { case Success.Code(): return http.StatusOK case ServerError.Code(): return http.StatusInternalServerError case InvalidParams.Code(): return http.StatusBadRequest case UnauthorizedAuthNotExist.Code(): fallthrough case UnauthorizedTokenError.Code(): fallthrough case UnauthorizedTokenGenerate.Code(): fallthrough case UnauthorizedTokenTimeout.Code(): return http.StatusUnauthorized case TooManyRequests.Code(): return http.StatusTooManyRequests } return http.StatusInternalServerError } in the common_code.go we use NewError method to create Error structure as the response towards error. codes is the carrier of global errcode. StatusCod method is used for StatusCode transformation of specific errcode, given a Error and match its Code to common error and return the matched one. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#errcodego"},{"categories":["Documentation"],"content":"Configuration Management use third party lib viper to manage conf go get -u github.com/spf13/viper ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#configuration-management"},{"categories":["Documentation"],"content":"configuration file create config.yaml in configs configs.yaml Server:RunMode:debugHttpPort:8080ReadTimeout:60WriteTimeout:60App:DefaultPageSize:10MaxPageSize:100LogSavePath:storage/logsLogFileName:appLogFileExt:.logDatabase:DBType:mysqlUsername:root # your own db usernamePassword:rootroot # your own db passwdHost:127.0.0.1:3306DBName:blog_serviceTablePrefix:blog_Charset:utf8ParseTime:TrueMaxIdleConns:10MaxOpenConns:30 in the configuration, we set the default settings for: Server: server conf, gin’s RunMode, default HTTP listening port, maximum read and write time APP: Application conf, default page size, maximum page size and default log save path Database: Database conf, required parameters of connecting to db instance ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#configuration-file"},{"categories":["Documentation"],"content":"configuration file create config.yaml in configs configs.yaml Server:RunMode:debugHttpPort:8080ReadTimeout:60WriteTimeout:60App:DefaultPageSize:10MaxPageSize:100LogSavePath:storage/logsLogFileName:appLogFileExt:.logDatabase:DBType:mysqlUsername:root # your own db usernamePassword:rootroot # your own db passwdHost:127.0.0.1:3306DBName:blog_serviceTablePrefix:blog_Charset:utf8ParseTime:TrueMaxIdleConns:10MaxOpenConns:30 in the configuration, we set the default settings for: Server: server conf, gin’s RunMode, default HTTP listening port, maximum read and write time APP: Application conf, default page size, maximum page size and default log save path Database: Database conf, required parameters of connecting to db instance ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#configsyaml"},{"categories":["Documentation"],"content":"component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#component"},{"categories":["Documentation"],"content":"component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo"},{"categories":["Documentation"],"content":"component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#sectiongo"},{"categories":["Documentation"],"content":"package gloabl variable To connect the conf and app, we should create global variable for us to use them. setting.go in global/ setting.go var ( ServerSetting *setting.ServerSettingS AppSetting *setting.AppSettingS DatabaseSetting *setting.DatabaseSettingS ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#package-gloabl-variable"},{"categories":["Documentation"],"content":"package gloabl variable To connect the conf and app, we should create global variable for us to use them. setting.go in global/ setting.go var ( ServerSetting *setting.ServerSettingS AppSetting *setting.AppSettingS DatabaseSetting *setting.DatabaseSettingS ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo-1"},{"categories":["Documentation"],"content":"initialize reading conf back to main.go ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#initialize-reading-conf"},{"categories":["Documentation"],"content":"main.go func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } } func main() {...} func setupSetting() error { setting, err := setting.NewSetting() if err != nil { return err } err = setting.ReadSection(\"Server\", \u0026global.ServerSetting) if err != nil { return err } err = setting.ReadSection(\"App\", \u0026global.AppSetting) if err != nil { return err } err = setting.ReadSection(\"Database\", \u0026global.DatabaseSetting) if err != nil { return err } global.ServerSetting.ReadTimeout *= time.Second global.ServerSetting.WriteTimeout *= time.Second return nil } init is used for initialize process in app, and is run automatically. Order is : init global variable =\u003e init method =\u003e main method ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:3","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#maingo"},{"categories":["Documentation"],"content":"modify server conf all we need to do is to set the conf and RunMode of gin in main.go func main() { gin.SetMode(global.ServerSetting.RunMode) router := routers.NewRouter() s := \u0026http.Server{ Addr: \":\" + global.ServerSetting.HttpPort, Handler: router, ReadTimeout: global.ServerSetting.ReadTimeout, WriteTimeout: global.ServerSetting.WriteTimeout, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:4","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#modify-server-conf"},{"categories":["Documentation"],"content":"DataBase Connection use third party lib gorm go get -u github.com/jinzhu/gorm ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#database-connection"},{"categories":["Documentation"],"content":"component add NewDBEngine method to model.go under internal/model/ model.go type Model struct {...} func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { db, err := gorm.Open(databaseSetting.DBType, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=%s\u0026parseTime=%t\u0026loc=Local\", databaseSetting.UserName, databaseSetting.Password, databaseSetting.Host, databaseSetting.DBName, databaseSetting.Charset, databaseSetting.ParseTime, )) if err != nil { return nil, err } if global.ServerSetting.RunMode == \"debug\" { db.LogMode(true) } db.SingularTable(true) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } NewDBEngine create a DB instance, and add the import of gorm and initialize MySQL driver lib github.com/jinzhu/gorm/dialects/mysql ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#component-1"},{"categories":["Documentation"],"content":"component add NewDBEngine method to model.go under internal/model/ model.go type Model struct {...} func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { db, err := gorm.Open(databaseSetting.DBType, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=%s\u0026parseTime=%t\u0026loc=Local\", databaseSetting.UserName, databaseSetting.Password, databaseSetting.Host, databaseSetting.DBName, databaseSetting.Charset, databaseSetting.ParseTime, )) if err != nil { return nil, err } if global.ServerSetting.RunMode == \"debug\" { db.LogMode(true) } db.SingularTable(true) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } NewDBEngine create a DB instance, and add the import of gorm and initialize MySQL driver lib github.com/jinzhu/gorm/dialects/mysql ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#modelgo"},{"categories":["Documentation"],"content":"package global variable create db.go in global db.go var ( DBEngine *gorm.DB ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#package-global-variable"},{"categories":["Documentation"],"content":"package global variable create db.go in global db.go var ( DBEngine *gorm.DB ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#dbgo"},{"categories":["Documentation"],"content":"initialization add method setupDBEngine to main.go ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:3","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#initialization"},{"categories":["Documentation"],"content":"main.go func init() { ... err = setupDBEngine() if err != nil { log.Fatalf(\"init.setupDBEngine err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error {...} func setupDBEngine() error { var err error global.DBEngine, err = model.NewDBEngine(global.DatabaseSetting) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:4","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#maingo-1"},{"categories":["Documentation"],"content":"Log go get -u gopkg.in/natefinch/lumberjack.v2 ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#log"},{"categories":["Documentation"],"content":"log classification create logger.go in pkg/logger/ logger.go type Level int8 type Fields map[string]interface{} const ( LevelDebug Level = iota LevelInfo LevelWarn LevelError LevelFatal LevelPanic ) func (l Level) String() string { switch l { case LevelDebug: return \"debug\" case LevelInfo: return \"info\" case LevelWarn: return \"warn\" case LevelError: return \"error\" case LevelFatal: return \"fatal\" case LevelPanic: return \"panic\" } return \"\" } We predefine the specific types of Level and Fields in app log, and categorize into Debug, Info, Warn, Error, Fatal, Panic. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#log-classification"},{"categories":["Documentation"],"content":"log classification create logger.go in pkg/logger/ logger.go type Level int8 type Fields map[string]interface{} const ( LevelDebug Level = iota LevelInfo LevelWarn LevelError LevelFatal LevelPanic ) func (l Level) String() string { switch l { case LevelDebug: return \"debug\" case LevelInfo: return \"info\" case LevelWarn: return \"warn\" case LevelError: return \"error\" case LevelFatal: return \"fatal\" case LevelPanic: return \"panic\" } return \"\" } We predefine the specific types of Level and Fields in app log, and categorize into Debug, Info, Warn, Error, Fatal, Panic. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo"},{"categories":["Documentation"],"content":"log standardization After categorize method, we shall work on methods for initialization of instance and standardized parameter binding ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#log-standardization"},{"categories":["Documentation"],"content":"logger.go type Logger struct { newLogger *log.Logger ctx context.Context fields Fields callers []string } func NewLogger(w io.Writer, prefix string, flag int) *Logger { l := log.New(w, prefix, flag) return \u0026Logger{newLogger: l} } func (l *Logger) clone() *Logger { nl := *l return \u0026nl } func (l *Logger) WithFields(f Fields) *Logger { ll := l.clone() if ll.fields == nil { ll.fields = make(Fields) } for k, v := range f { ll.fields[k] = v } return ll } func (l *Logger) WithContext(ctx context.Context) *Logger { ll := l.clone() ll.ctx = ctx return ll } func (l *Logger) WithCaller(skip int) *Logger { ll := l.clone() pc, file, line, ok := runtime.Caller(skip) if ok { f := runtime.FuncForPC(pc) ll.callers = []string{fmt.Sprintf(\"%s: %d %s\", file, line, f.Name())} } return ll } func (l *Logger) WithCallersFrames() *Logger { maxCallerDepth := 25 minCallerDepth := 1 callers := []string{} pcs := make([]uintptr, maxCallerDepth) depth := runtime.Callers(minCallerDepth, pcs) frames := runtime.CallersFrames(pcs[:depth]) for frame, more := frames.Next(); more; frame, more = frames.Next() { callers = append(callers, fmt.Sprintf(\"%s: %d %s\", frame.File, frame.Line, frame.Function)) if !more { break } } ll := l.clone() ll.callers = callers return ll } WithLevel: Set log level WithFields: Set log public fields WithContext: Set log context attribute WithCaller: Set one caller’s information WithCallerFrames: Set all caller’s information ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:3","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-1"},{"categories":["Documentation"],"content":"log formatting \u0026 output ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:4","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#log-formatting--output"},{"categories":["Documentation"],"content":"logger.go func (l *Logger) JSONFormat(level Level, message string) map[string]interface{} { data := make(Fields, len(l.fields)+4) data[\"level\"] = level.String() data[\"time\"] = time.Now().Local().UnixNano() data[\"message\"] = message data[\"callers\"] = l.callers if len(l.fields) \u003e 0 { for k, v := range l.fields { if _, ok := data[k]; !ok { data[k] = v } } } return data } func (l *Logger) Output(level Level, message string) { body, _ := json.Marshal(l.JSONFormat(level, message)) content := string(body) switch level { case LevelDebug: l.newLogger.Print(content) case LevelInfo: l.newLogger.Print(content) case LevelWarn: l.newLogger.Print(content) case LevelError: l.newLogger.Print(content) case LevelFatal: l.newLogger.Fatal(content) case LevelPanic: l.newLogger.Panic(content) } } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:5","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-2"},{"categories":["Documentation"],"content":"log classified output ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:6","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#log-classified-output"},{"categories":["Documentation"],"content":"logger.go func (l *Logger) Info(v ...interface{}) { l.Output(LevelInfo, fmt.Sprint(v...)) } func (l *Logger) Infof(format string, v ...interface{}) { l.Output(LevelInfo, fmt.Sprintf(format, v...)) } func (l *Logger) Fatal(v ...interface{}) { l.Output(LevelFatal, fmt.Sprint(v...)) } func (l *Logger) Fatalf(format string, v ...interface{}) { l.Output(LevelFatal, fmt.Sprintf(format, v...)) } ... code above just shows info and Fatal output, other level code is no difference but the name and Withlevel. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:7","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-3"},{"categories":["Documentation"],"content":"package global variable after we finish the logger, we need to define a Logger object for our app to use. So, we open the global/setting.go file, add following contents. setting.go var ( ... Logger *logger.Logger ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:8","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#package-global-variable-1"},{"categories":["Documentation"],"content":"package global variable after we finish the logger, we need to define a Logger object for our app to use. So, we open the global/setting.go file, add following contents. setting.go var ( ... Logger *logger.Logger ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:8","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo-2"},{"categories":["Documentation"],"content":"initialization next, we should modify the main.go in the root directory, add on initialization for the Logger object we just defined func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } err = setupLogger() if err != nil { log.Fatalf(\"init.setupLogger err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error { global.Logger = logger.NewLogger(\u0026lumberjack.Logger{ Filename: global.AppSetting.LogSavePath + \"/\" + global.AppSetting.LogFileName + global.AppSetting.LogFileExt, MaxSize: 600, MaxAge: 10, LocalTime: true, }, \"\", log.LstdFlags).WithCaller(2) return nil } we add logger component through this file, and initialize the global variable Logger inside method setupLogger. Being aware that we use lumberjack as logger’s io.writer. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:9","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#initialization-1"},{"categories":["Documentation"],"content":"In this chapter, we majorly deal with project structure, interface, router. ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:0:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#"},{"categories":["Documentation"],"content":"structure blog-service ├── configs ├── docs ├── global ├── internal │ ├── dao │ ├── middleware │ ├── model │ ├── routers │ └── service ├── pkg ├── storage ├── scripts └── third_party ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:1:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#structure"},{"categories":["Documentation"],"content":"Model The attributes of objects have in common should create an individual model to store . ├── internal/ │ └── model/ │ ├──model.go │ ├──tag.go │ ├──article.go │ └──article_tag.go and in each table model should contain the *Model tag.go type Tag struct { *Model Name string `json:\"name\"` State uint8 `json:\"state\"` } func (t Tag) TableName() string { return \"blog_tag\" } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:2:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#model"},{"categories":["Documentation"],"content":"Model The attributes of objects have in common should create an individual model to store . ├── internal/ │ └── model/ │ ├──model.go │ ├──tag.go │ ├──article.go │ └──article_tag.go and in each table model should contain the *Model tag.go type Tag struct { *Model Name string `json:\"name\"` State uint8 `json:\"state\"` } func (t Tag) TableName() string { return \"blog_tag\" } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:2:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#taggo"},{"categories":["Documentation"],"content":"Router ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:0","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#router"},{"categories":["Documentation"],"content":"Router management decide the business api and declare the create method in internal/routers router.go func NewRouter() *gin.Engine { r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) apiv1 := r.Group(\"/api/v1\") { apiv1.POST(\"/tags\") apiv1.DELETE(\"/tags/:id\") apiv1.PUT(\"/tags/:id\") apiv1.PATCH(\"/tags/:id/state\") apiv1.GET(\"/tags\") apiv1.POST(\"/articles\") apiv1.DELETE(\"/articles/:id\") apiv1.PUT(\"/articles/:id\") apiv1.PATCH(\"/articles/:id/state\") apiv1.GET(\"/articles/:id\") apiv1.GET(\"/articles\") } return r } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:1","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#router-management"},{"categories":["Documentation"],"content":"Router handler api handler should be stored inside the internal/routers/api, dir name is the api’s version tag.go type Tag struct {} func NewTag() Tag { return Tag{} } func (t Tag) Get(c *gin.Context) {} func (t Tag) List(c *gin.Context) {} func (t Tag) Create(c *gin.Context) {} func (t Tag) Update(c *gin.Context) {} func (t Tag) Delete(c *gin.Context) {} ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#router-handler"},{"categories":["Documentation"],"content":"Router handler api handler should be stored inside the internal/routers/api, dir name is the api’s version tag.go type Tag struct {} func NewTag() Tag { return Tag{} } func (t Tag) Get(c *gin.Context) {} func (t Tag) List(c *gin.Context) {} func (t Tag) Create(c *gin.Context) {} func (t Tag) Update(c *gin.Context) {} func (t Tag) Delete(c *gin.Context) {} ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:2","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#taggo-1"},{"categories":["Documentation"],"content":"Boot access modify main.go, set parameters like TCP Endpoint, Readtime of http.Server main.go func main() { router := routers.NewRouter() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:3","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#boot-access"},{"categories":["Documentation"],"content":"Boot access modify main.go, set parameters like TCP Endpoint, Readtime of http.Server main.go func main() { router := routers.NewRouter() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:3","series":null,"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#maingo"}]