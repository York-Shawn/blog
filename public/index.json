[{"categories":["Documentation"],"content":"In this chapter, we gonna make basic module and public module. These module seldom associate with core business, their task is to connect different parts of app, and make app a closed loop. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:0:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#"},{"categories":["Documentation"],"content":"1. Standerlized ErrorCode ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#1-standerlized-errorcode"},{"categories":["Documentation"],"content":"1.1 common errcode predefine common errcode in pkg/errcode to guide users var ( Success = NewError(0, \"成功\") ServerError = NewError(10000000, \"服务内部错误\") InvalidParams = NewError(10000001, \"入参错误\") NotFound = NewError(10000002, \"找不到\") UnauthorizedAuthNotExist = NewError(10000003, \"鉴权失败，找不到对应的 AppKey 和 AppSecret\") UnauthorizedTokenError = NewError(10000004, \"鉴权失败，Token 错误\") UnauthorizedTokenTimeout = NewError(10000005, \"鉴权失败，Token 超时\") UnauthorizedTokenGenerate = NewError(10000006, \"鉴权失败，Token 生成失败\") TooManyRequests = NewError(10000007, \"请求过多\") ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#11-common-errcode"},{"categories":["Documentation"],"content":"1.2 error handler create errcode.go in pkg/errcode, write some public methods od error handling to standerlized our error output. errcode.go type Error struct { code int `json:\"code\"` msg string `json:\"msg\"` details []string `json:\"details\"` } var codes = map[int]string{} func NewError(code int, msg string) *Error { if _, ok := codes[code]; ok { panic(fmt.Sprintf(\"错误码 %d 已经存在，请更换一个\", code)) } codes[code] = msg return \u0026Error{code: code, msg: msg} } func (e *Error) Error() string { return fmt.Sprintf(\"错误码：%d, 错误信息:：%s\", e.Code(), e.Msg()) } func (e *Error) Code() int { return e.code } func (e *Error) Msg() string { return e.msg } func (e *Error) Msgf(args []interface{}) string { return fmt.Sprintf(e.msg, args...) } func (e *Error) Details() []string { return e.details } func (e *Error) WithDetails(details ...string) *Error { newError := *e newError.details = []string{} for _, d := range details { newError.details = append(newError.details, d) } return \u0026newError } func (e *Error) StatusCode() int { switch e.Code() { case Success.Code(): return http.StatusOK case ServerError.Code(): return http.StatusInternalServerError case InvalidParams.Code(): return http.StatusBadRequest case UnauthorizedAuthNotExist.Code(): fallthrough case UnauthorizedTokenError.Code(): fallthrough case UnauthorizedTokenGenerate.Code(): fallthrough case UnauthorizedTokenTimeout.Code(): return http.StatusUnauthorized case TooManyRequests.Code(): return http.StatusTooManyRequests } return http.StatusInternalServerError } in the common_code.go we use NewError method to create Error structure as the response towards error. codes is the carrier of global errcode. StatusCod method is used for StatusCode transformation of specific errcode, given a Error and match its Code to common error and return the matched one. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#12-error-handler"},{"categories":["Documentation"],"content":"1.2 error handler create errcode.go in pkg/errcode, write some public methods od error handling to standerlized our error output. errcode.go type Error struct { code int `json:\"code\"` msg string `json:\"msg\"` details []string `json:\"details\"` } var codes = map[int]string{} func NewError(code int, msg string) *Error { if _, ok := codes[code]; ok { panic(fmt.Sprintf(\"错误码 %d 已经存在，请更换一个\", code)) } codes[code] = msg return \u0026Error{code: code, msg: msg} } func (e *Error) Error() string { return fmt.Sprintf(\"错误码：%d, 错误信息:：%s\", e.Code(), e.Msg()) } func (e *Error) Code() int { return e.code } func (e *Error) Msg() string { return e.msg } func (e *Error) Msgf(args []interface{}) string { return fmt.Sprintf(e.msg, args...) } func (e *Error) Details() []string { return e.details } func (e *Error) WithDetails(details ...string) *Error { newError := *e newError.details = []string{} for _, d := range details { newError.details = append(newError.details, d) } return \u0026newError } func (e *Error) StatusCode() int { switch e.Code() { case Success.Code(): return http.StatusOK case ServerError.Code(): return http.StatusInternalServerError case InvalidParams.Code(): return http.StatusBadRequest case UnauthorizedAuthNotExist.Code(): fallthrough case UnauthorizedTokenError.Code(): fallthrough case UnauthorizedTokenGenerate.Code(): fallthrough case UnauthorizedTokenTimeout.Code(): return http.StatusUnauthorized case TooManyRequests.Code(): return http.StatusTooManyRequests } return http.StatusInternalServerError } in the common_code.go we use NewError method to create Error structure as the response towards error. codes is the carrier of global errcode. StatusCod method is used for StatusCode transformation of specific errcode, given a Error and match its Code to common error and return the matched one. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:1:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#errcodego"},{"categories":["Documentation"],"content":"2. Configuration Management use third party lib viper to manage conf go get -u github.com/spf13/viper ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#2-configuration-management"},{"categories":["Documentation"],"content":"2.1 configuration file create config.yaml in configs configs.yaml Server:RunMode:debugHttpPort:8080ReadTimeout:60WriteTimeout:60App:DefaultPageSize:10MaxPageSize:100LogSavePath:storage/logsLogFileName:appLogFileExt:.logDatabase:DBType:mysqlUsername:root # your own db usernamePassword:rootroot # your own db passwdHost:127.0.0.1:3306DBName:blog_serviceTablePrefix:blog_Charset:utf8ParseTime:TrueMaxIdleConns:10MaxOpenConns:30 in the configuration, we set the default settings for: Server: server conf, gin’s RunMode, default HTTP listening port, maximum read and write time APP: Application conf, default page size, maximum page size and default log save path Database: Database conf, required parameters of connecting to db instance ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#21-configuration-file"},{"categories":["Documentation"],"content":"2.1 configuration file create config.yaml in configs configs.yaml Server:RunMode:debugHttpPort:8080ReadTimeout:60WriteTimeout:60App:DefaultPageSize:10MaxPageSize:100LogSavePath:storage/logsLogFileName:appLogFileExt:.logDatabase:DBType:mysqlUsername:root # your own db usernamePassword:rootroot # your own db passwdHost:127.0.0.1:3306DBName:blog_serviceTablePrefix:blog_Charset:utf8ParseTime:TrueMaxIdleConns:10MaxOpenConns:30 in the configuration, we set the default settings for: Server: server conf, gin’s RunMode, default HTTP listening port, maximum read and write time APP: Application conf, default page size, maximum page size and default log save path Database: Database conf, required parameters of connecting to db instance ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#configsyaml"},{"categories":["Documentation"],"content":"2.2 write component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#22-write-component"},{"categories":["Documentation"],"content":"2.2 write component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo"},{"categories":["Documentation"],"content":"2.2 write component after configuration file, encapsulate the method of reading conf. create setting.go in pkg/setting setting.go type Setting struct { vp *viper.Viper } func NewSetting() (*Setting, error) { vp := viper.New() vp.SetConfigName(\"config\") vp.AddConfigPath(\"configs/\") vp.SetConfigType(\"yaml\") err := vp.ReadInConfig() if err != nil { return nil, err } return \u0026Setting{vp}, nil } NewSetting to initialize basic attribute of project’s configuration.Set config file name as config, type as yaml, and config file path as configs/ Next we gonna create section.go in the same dir to declare the module of conf attribute and write methods to read setting in sections. section.go type ServerSettingS struct { RunMode string HttpPort string ReadTimeout time.Duration WriteTimeout time.Duration } type AppSettingS struct { DefaultPageSize int MaxPageSize int LogSavePath string LogFileName string LogFileExt string } type DatabaseSettingS struct { DBType string UserName string Password string Host string DBName string TablePrefix string Charset string ParseTime bool MaxIdleConns int MaxOpenConns int } func (s *Setting) ReadSection(k string, v interface{}) error { err := s.vp.UnmarshalKey(k, v) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#sectiongo"},{"categories":["Documentation"],"content":"2.3 package gloabl variable To connect the conf and app, we should create global variable for us to use them. setting.go in global/ setting.go var ( ServerSetting *setting.ServerSettingS AppSetting *setting.AppSettingS DatabaseSetting *setting.DatabaseSettingS ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#23-package-gloabl-variable"},{"categories":["Documentation"],"content":"2.3 package gloabl variable To connect the conf and app, we should create global variable for us to use them. setting.go in global/ setting.go var ( ServerSetting *setting.ServerSettingS AppSetting *setting.AppSettingS DatabaseSetting *setting.DatabaseSettingS ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo-1"},{"categories":["Documentation"],"content":"2.4 initialize reading conf back to main.go main.go func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } } func main() {...} func setupSetting() error { setting, err := setting.NewSetting() if err != nil { return err } err = setting.ReadSection(\"Server\", \u0026global.ServerSetting) if err != nil { return err } err = setting.ReadSection(\"App\", \u0026global.AppSetting) if err != nil { return err } err = setting.ReadSection(\"Database\", \u0026global.DatabaseSetting) if err != nil { return err } global.ServerSetting.ReadTimeout *= time.Second global.ServerSetting.WriteTimeout *= time.Second return nil } init is used for initialize process in app, and is run automatically. Order is : init global variable =\u003e init method =\u003e main method ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:4","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#24-initialize-reading-conf"},{"categories":["Documentation"],"content":"2.4 initialize reading conf back to main.go main.go func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } } func main() {...} func setupSetting() error { setting, err := setting.NewSetting() if err != nil { return err } err = setting.ReadSection(\"Server\", \u0026global.ServerSetting) if err != nil { return err } err = setting.ReadSection(\"App\", \u0026global.AppSetting) if err != nil { return err } err = setting.ReadSection(\"Database\", \u0026global.DatabaseSetting) if err != nil { return err } global.ServerSetting.ReadTimeout *= time.Second global.ServerSetting.WriteTimeout *= time.Second return nil } init is used for initialize process in app, and is run automatically. Order is : init global variable = init method = main method ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:4","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#maingo"},{"categories":["Documentation"],"content":"2.5 modify server conf all we need to do is to set the conf and RunMode of gin in main.go func main() { gin.SetMode(global.ServerSetting.RunMode) router := routers.NewRouter() s := \u0026http.Server{ Addr: \":\" + global.ServerSetting.HttpPort, Handler: router, ReadTimeout: global.ServerSetting.ReadTimeout, WriteTimeout: global.ServerSetting.WriteTimeout, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:2:5","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#25-modify-server-conf"},{"categories":["Documentation"],"content":"3. DataBase Connection use third party lib gorm go get -u github.com/jinzhu/gorm ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#3-database-connection"},{"categories":["Documentation"],"content":"3.1 component add NewDBEngine method to model.go under internal/model/ model.go type Model struct {...} func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { db, err := gorm.Open(databaseSetting.DBType, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=%s\u0026parseTime=%t\u0026loc=Local\", databaseSetting.UserName, databaseSetting.Password, databaseSetting.Host, databaseSetting.DBName, databaseSetting.Charset, databaseSetting.ParseTime, )) if err != nil { return nil, err } if global.ServerSetting.RunMode == \"debug\" { db.LogMode(true) } db.SingularTable(true) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } NewDBEngine create a DB instance, and add the import of gorm and initialize MySQL driver lib github.com/jinzhu/gorm/dialects/mysql ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#31-component"},{"categories":["Documentation"],"content":"3.1 component add NewDBEngine method to model.go under internal/model/ model.go type Model struct {...} func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { db, err := gorm.Open(databaseSetting.DBType, fmt.Sprintf(\"%s:%s@tcp(%s)/%s?charset=%s\u0026parseTime=%t\u0026loc=Local\", databaseSetting.UserName, databaseSetting.Password, databaseSetting.Host, databaseSetting.DBName, databaseSetting.Charset, databaseSetting.ParseTime, )) if err != nil { return nil, err } if global.ServerSetting.RunMode == \"debug\" { db.LogMode(true) } db.SingularTable(true) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } NewDBEngine create a DB instance, and add the import of gorm and initialize MySQL driver lib github.com/jinzhu/gorm/dialects/mysql ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#modelgo"},{"categories":["Documentation"],"content":"3.2 package global variable create db.go in global db.go var ( DBEngine *gorm.DB ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#32-package-global-variable"},{"categories":["Documentation"],"content":"3.2 package global variable create db.go in global db.go var ( DBEngine *gorm.DB ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#dbgo"},{"categories":["Documentation"],"content":"3.3 initialization add method setupDBEngine to main.go main.go func init() { ... err = setupDBEngine() if err != nil { log.Fatalf(\"init.setupDBEngine err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error {...} func setupDBEngine() error { var err error global.DBEngine, err = model.NewDBEngine(global.DatabaseSetting) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#33-initialization"},{"categories":["Documentation"],"content":"3.3 initialization add method setupDBEngine to main.go main.go func init() { ... err = setupDBEngine() if err != nil { log.Fatalf(\"init.setupDBEngine err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error {...} func setupDBEngine() error { var err error global.DBEngine, err = model.NewDBEngine(global.DatabaseSetting) if err != nil { return err } return nil } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#maingo-1"},{"categories":["Documentation"],"content":"4. Log go get -u gopkg.in/natefinch/lumberjack.v2 ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#4-log"},{"categories":["Documentation"],"content":"4.1 log classification create logger.go in pkg/logger/ logger.go type Level int8 type Fields map[string]interface{} const ( LevelDebug Level = iota LevelInfo LevelWarn LevelError LevelFatal LevelPanic ) func (l Level) String() string { switch l { case LevelDebug: return \"debug\" case LevelInfo: return \"info\" case LevelWarn: return \"warn\" case LevelError: return \"error\" case LevelFatal: return \"fatal\" case LevelPanic: return \"panic\" } return \"\" } We predefine the specific types of Level and Fields in app log, and categorize into Debug, Info, Warn, Error, Fatal, Panic. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#41-log-classification"},{"categories":["Documentation"],"content":"4.1 log classification create logger.go in pkg/logger/ logger.go type Level int8 type Fields map[string]interface{} const ( LevelDebug Level = iota LevelInfo LevelWarn LevelError LevelFatal LevelPanic ) func (l Level) String() string { switch l { case LevelDebug: return \"debug\" case LevelInfo: return \"info\" case LevelWarn: return \"warn\" case LevelError: return \"error\" case LevelFatal: return \"fatal\" case LevelPanic: return \"panic\" } return \"\" } We predefine the specific types of Level and Fields in app log, and categorize into Debug, Info, Warn, Error, Fatal, Panic. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo"},{"categories":["Documentation"],"content":"4.2 log standardization After categorize method, we shall work on methods for initialization of instance and standardized parameter binding logger.go type Logger struct { newLogger *log.Logger ctx context.Context fields Fields callers []string } func NewLogger(w io.Writer, prefix string, flag int) *Logger { l := log.New(w, prefix, flag) return \u0026Logger{newLogger: l} } func (l *Logger) clone() *Logger { nl := *l return \u0026nl } func (l *Logger) WithFields(f Fields) *Logger { ll := l.clone() if ll.fields == nil { ll.fields = make(Fields) } for k, v := range f { ll.fields[k] = v } return ll } func (l *Logger) WithContext(ctx context.Context) *Logger { ll := l.clone() ll.ctx = ctx return ll } func (l *Logger) WithCaller(skip int) *Logger { ll := l.clone() pc, file, line, ok := runtime.Caller(skip) if ok { f := runtime.FuncForPC(pc) ll.callers = []string{fmt.Sprintf(\"%s: %d %s\", file, line, f.Name())} } return ll } func (l *Logger) WithCallersFrames() *Logger { maxCallerDepth := 25 minCallerDepth := 1 callers := []string{} pcs := make([]uintptr, maxCallerDepth) depth := runtime.Callers(minCallerDepth, pcs) frames := runtime.CallersFrames(pcs[:depth]) for frame, more := frames.Next(); more; frame, more = frames.Next() { callers = append(callers, fmt.Sprintf(\"%s: %d %s\", frame.File, frame.Line, frame.Function)) if !more { break } } ll := l.clone() ll.callers = callers return ll } WithLevel: Set log level WithFields: Set log public fields WithContext: Set log context attribute WithCaller: Set one caller’s information WithCallerFrames: Set all caller’s information ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#42-log-standardization"},{"categories":["Documentation"],"content":"4.2 log standardization After categorize method, we shall work on methods for initialization of instance and standardized parameter binding logger.go type Logger struct { newLogger *log.Logger ctx context.Context fields Fields callers []string } func NewLogger(w io.Writer, prefix string, flag int) *Logger { l := log.New(w, prefix, flag) return \u0026Logger{newLogger: l} } func (l *Logger) clone() *Logger { nl := *l return \u0026nl } func (l *Logger) WithFields(f Fields) *Logger { ll := l.clone() if ll.fields == nil { ll.fields = make(Fields) } for k, v := range f { ll.fields[k] = v } return ll } func (l *Logger) WithContext(ctx context.Context) *Logger { ll := l.clone() ll.ctx = ctx return ll } func (l *Logger) WithCaller(skip int) *Logger { ll := l.clone() pc, file, line, ok := runtime.Caller(skip) if ok { f := runtime.FuncForPC(pc) ll.callers = []string{fmt.Sprintf(\"%s: %d %s\", file, line, f.Name())} } return ll } func (l *Logger) WithCallersFrames() *Logger { maxCallerDepth := 25 minCallerDepth := 1 callers := []string{} pcs := make([]uintptr, maxCallerDepth) depth := runtime.Callers(minCallerDepth, pcs) frames := runtime.CallersFrames(pcs[:depth]) for frame, more := frames.Next(); more; frame, more = frames.Next() { callers = append(callers, fmt.Sprintf(\"%s: %d %s\", frame.File, frame.Line, frame.Function)) if !more { break } } ll := l.clone() ll.callers = callers return ll } WithLevel: Set log level WithFields: Set log public fields WithContext: Set log context attribute WithCaller: Set one caller’s information WithCallerFrames: Set all caller’s information ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-1"},{"categories":["Documentation"],"content":"4.3 log formatting \u0026 output logger.go func (l *Logger) JSONFormat(level Level, message string) map[string]interface{} { data := make(Fields, len(l.fields)+4) data[\"level\"] = level.String() data[\"time\"] = time.Now().Local().UnixNano() data[\"message\"] = message data[\"callers\"] = l.callers if len(l.fields) \u003e 0 { for k, v := range l.fields { if _, ok := data[k]; !ok { data[k] = v } } } return data } func (l *Logger) Output(level Level, message string) { body, _ := json.Marshal(l.JSONFormat(level, message)) content := string(body) switch level { case LevelDebug: l.newLogger.Print(content) case LevelInfo: l.newLogger.Print(content) case LevelWarn: l.newLogger.Print(content) case LevelError: l.newLogger.Print(content) case LevelFatal: l.newLogger.Fatal(content) case LevelPanic: l.newLogger.Panic(content) } } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#43-log-formatting--output"},{"categories":["Documentation"],"content":"4.3 log formatting \u0026 output logger.go func (l *Logger) JSONFormat(level Level, message string) map[string]interface{} { data := make(Fields, len(l.fields)+4) data[\"level\"] = level.String() data[\"time\"] = time.Now().Local().UnixNano() data[\"message\"] = message data[\"callers\"] = l.callers if len(l.fields) 0 { for k, v := range l.fields { if _, ok := data[k]; !ok { data[k] = v } } } return data } func (l *Logger) Output(level Level, message string) { body, _ := json.Marshal(l.JSONFormat(level, message)) content := string(body) switch level { case LevelDebug: l.newLogger.Print(content) case LevelInfo: l.newLogger.Print(content) case LevelWarn: l.newLogger.Print(content) case LevelError: l.newLogger.Print(content) case LevelFatal: l.newLogger.Fatal(content) case LevelPanic: l.newLogger.Panic(content) } } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-2"},{"categories":["Documentation"],"content":"4.4 log classified output logger.go func (l *Logger) Info(v ...interface{}) { l.Output(LevelInfo, fmt.Sprint(v...)) } func (l *Logger) Infof(format string, v ...interface{}) { l.Output(LevelInfo, fmt.Sprintf(format, v...)) } func (l *Logger) Fatal(v ...interface{}) { l.Output(LevelFatal, fmt.Sprint(v...)) } func (l *Logger) Fatalf(format string, v ...interface{}) { l.Output(LevelFatal, fmt.Sprintf(format, v...)) } ... code above just shows info and Fatal output, other level code is no difference but the name and Withlevel. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:4","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#44-log-classified-output"},{"categories":["Documentation"],"content":"4.4 log classified output logger.go func (l *Logger) Info(v ...interface{}) { l.Output(LevelInfo, fmt.Sprint(v...)) } func (l *Logger) Infof(format string, v ...interface{}) { l.Output(LevelInfo, fmt.Sprintf(format, v...)) } func (l *Logger) Fatal(v ...interface{}) { l.Output(LevelFatal, fmt.Sprint(v...)) } func (l *Logger) Fatalf(format string, v ...interface{}) { l.Output(LevelFatal, fmt.Sprintf(format, v...)) } ... code above just shows info and Fatal output, other level code is no difference but the name and Withlevel. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:4","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#loggergo-3"},{"categories":["Documentation"],"content":"4.5 package global variable after we finish the logger, we need to define a Logger object for our app to use. So, we open the global/setting.go file, add following contents. setting.go var ( ... Logger *logger.Logger ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:5","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#45-package-global-variable"},{"categories":["Documentation"],"content":"4.5 package global variable after we finish the logger, we need to define a Logger object for our app to use. So, we open the global/setting.go file, add following contents. setting.go var ( ... Logger *logger.Logger ) ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:5","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#settinggo-2"},{"categories":["Documentation"],"content":"4.6 initialization next, we should modify the main.go in the root directory, add on initialization for the Logger object we just defined func init() { err := setupSetting() if err != nil { log.Fatalf(\"init.setupSetting err: %v\", err) } err = setupLogger() if err != nil { log.Fatalf(\"init.setupLogger err: %v\", err) } } func main() {...} func setupSetting() error {...} func setupLogger() error { global.Logger = logger.NewLogger(\u0026lumberjack.Logger{ Filename: global.AppSetting.LogSavePath + \"/\" + global.AppSetting.LogFileName + global.AppSetting.LogFileExt, MaxSize: 600, MaxAge: 10, LocalTime: true, }, \"\", log.LstdFlags).WithCaller(2) return nil } we add logger component through this file, and initialize the global variable Logger inside method setupLogger. Being aware that we use lumberjack as logger’s io.writer. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:4:6","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#46-initialization"},{"categories":["Documentation"],"content":"5. Response Handling In application, port from server bond to client, then how do server know know the result of interface call. Generally speaking, it depends on the HTTP status code and response the interface returned, and the judgement is based on the response results defined in advance according to the specification. Therefore in this subsection we’ll write the response handling method returned by the Unified Processing Interface, which also correspond to error code standardization. ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#5-response-handling"},{"categories":["Documentation"],"content":"5.1 type converting create convert.go under pkg/convert convert.go type StrTo string func (s StrTo) String() string { return string(s) } func (s StrTo) Int() (int, error) { v, err := strconv.Atoi(s.String()) return v, err } func (s StrTo) MustInt() int { v, _ := s.Int() return v } func (s StrTo) UInt32() (uint32, error) { v, err := strconv.Atoi(s.String()) return uint32(v), err } func (s StrTo) MustUInt32() uint32 { v, _ := s.UInt32() return v } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#51-type-converting"},{"categories":["Documentation"],"content":"5.1 type converting create convert.go under pkg/convert convert.go type StrTo string func (s StrTo) String() string { return string(s) } func (s StrTo) Int() (int, error) { v, err := strconv.Atoi(s.String()) return v, err } func (s StrTo) MustInt() int { v, _ := s.Int() return v } func (s StrTo) UInt32() (uint32, error) { v, err := strconv.Atoi(s.String()) return uint32(v), err } func (s StrTo) MustUInt32() uint32 { v, _ := s.UInt32() return v } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#convertgo"},{"categories":["Documentation"],"content":"5.2 paging handling create pagination.go under pkg/app pagination.go func GetPage(c *gin.Context) int { page := convert.StrTo(c.Query(\"page\")).MustInt() if page \u003c= 0 { return 1 } return page } func GetPageSize(c *gin.Context) int { pageSize := convert.StrTo(c.Query(\"page_size\")).MustInt() if pageSize \u003c= 0 { return global.AppSetting.DefaultPageSize } if pageSize \u003e global.AppSetting.MaxPageSize { return global.AppSetting.MaxPageSize } return pageSize } func GetPageOffset(page, pageSize int) int { result := 0 if page \u003e 0 { result = (page - 1) * pageSize } return result } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#52-paging-handling"},{"categories":["Documentation"],"content":"5.2 paging handling create pagination.go under pkg/app pagination.go func GetPage(c *gin.Context) int { page := convert.StrTo(c.Query(\"page\")).MustInt() if page global.AppSetting.MaxPageSize { return global.AppSetting.MaxPageSize } return pageSize } func GetPageOffset(page, pageSize int) int { result := 0 if page 0 { result = (page - 1) * pageSize } return result } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#paginationgo"},{"categories":["Documentation"],"content":"5.3 response handling create app.go under pkg/app app.go type Response struct { Ctx *gin.Context } type Pager struct { Page int `json:\"page\"` PageSize int `json:\"page_size\"` TotalRows int `json:\"total_rows\"` } func NewResponse(ctx *gin.Context) *Response { return \u0026Response{Ctx: ctx} } func (r *Response) ToResponse(data interface{}) { if data == nil { data = gin.H{} } r.Ctx.JSON(http.StatusOK, data) } func (r *Response) ToResponseList(list interface{}, totalRows int) { r.Ctx.JSON(http.StatusOK, gin.H{ \"list\": list, \"pager\": Pager{ Page: GetPage(r.Ctx), PageSize: GetPageSize(r.Ctx), TotalRows: totalRows, }, }) } func (r *Response) ToErrorResponse(err *errcode.Error) { response := gin.H{\"code\": err.Code(), \"msg\": err.Msg()} details := err.Details() if len(details) \u003e 0 { response[\"details\"] = details } r.Ctx.JSON(err.StatusCode(), response) } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#53-response-handling"},{"categories":["Documentation"],"content":"5.3 response handling create app.go under pkg/app app.go type Response struct { Ctx *gin.Context } type Pager struct { Page int `json:\"page\"` PageSize int `json:\"page_size\"` TotalRows int `json:\"total_rows\"` } func NewResponse(ctx *gin.Context) *Response { return \u0026Response{Ctx: ctx} } func (r *Response) ToResponse(data interface{}) { if data == nil { data = gin.H{} } r.Ctx.JSON(http.StatusOK, data) } func (r *Response) ToResponseList(list interface{}, totalRows int) { r.Ctx.JSON(http.StatusOK, gin.H{ \"list\": list, \"pager\": Pager{ Page: GetPage(r.Ctx), PageSize: GetPageSize(r.Ctx), TotalRows: totalRows, }, }) } func (r *Response) ToErrorResponse(err *errcode.Error) { response := gin.H{\"code\": err.Code(), \"msg\": err.Msg()} details := err.Details() if len(details) 0 { response[\"details\"] = details } r.Ctx.JSON(err.StatusCode(), response) } ","date":"2021-03-11","objectID":"/posts/gin-tutorial-2/:5:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-2","uri":"/posts/gin-tutorial-2/#appgo"},{"categories":["Document"],"content":"This chapter is about Tag Management Module development ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:0:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#"},{"categories":["Document"],"content":"3.1 Create model method first we need to deal with tag table, create tag.go under internal/model, then encapsulate operation of tag model. tag.go func (t Tag) Count(db *gorm.DB) (int, error) { var count int if t.Name != \"\" { db = db.Where(\"name = ?\", t.Name) } db = db.Where(\"state = ?\", t.State) if err := db.Model(\u0026t).Where(\"is_del = ?\", 0).Count(\u0026count).Error; err != nil { return 0, err } return count, nil } func (t Tag) List(db *gorm.DB, pageOffset, pageSize int) ([]*Tag, error) { var tags []*Tag var err error if pageOffset \u003e= 0 \u0026\u0026 pageSize \u003e 0 { db = db.Offset(pageOffset).Limit(pageSize) } if t.Name != \"\" { db = db.Where(\"name = ?\", t.Name) } db = db.Where(\"state = ?\", t.State) if err = db.Where(\"is_del = ?\", 0).Find(\u0026tags).Error; err != nil { return nil, err } return tags, nil } func (t Tag) Create(db *gorm.DB) error { return db.Create(\u0026t).Error } func (t Tag) Update(db *gorm.DB, values interface{}) error { if err := db.Model(t).Where(\"id = ? AND is_del = ?\", t.ID, 0).Updates(values).Error; err != nil { return err } return nil } func (t Tag) Delete(db *gorm.DB) error { return db.Where(\"id = ? AND is_del = ?\", t.Model.ID, 0).Delete(\u0026t).Error } func (t Tag) Get(db *gorm.DB) (Tag, error) { var tag Tag err := db.Where(\"id = ? AND is_del = ? AND state = ?\", t.ID, 0, t.State).First(\u0026tag).Error if err != nil \u0026\u0026 err != gorm.ErrRecordNotFound { return tag, err } return tag, nil } Model: specify the model which runs DB operation Where: set filter, accept map, struct, string as conditions Offset: specify the numbers of records to skip before return the records Limit: specify the number of records to be retrieved ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:1:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#31-create-model-method"},{"categories":["Document"],"content":"3.1 Create model method first we need to deal with tag table, create tag.go under internal/model, then encapsulate operation of tag model. tag.go func (t Tag) Count(db *gorm.DB) (int, error) { var count int if t.Name != \"\" { db = db.Where(\"name = ?\", t.Name) } db = db.Where(\"state = ?\", t.State) if err := db.Model(\u0026t).Where(\"is_del = ?\", 0).Count(\u0026count).Error; err != nil { return 0, err } return count, nil } func (t Tag) List(db *gorm.DB, pageOffset, pageSize int) ([]*Tag, error) { var tags []*Tag var err error if pageOffset = 0 \u0026\u0026 pageSize 0 { db = db.Offset(pageOffset).Limit(pageSize) } if t.Name != \"\" { db = db.Where(\"name = ?\", t.Name) } db = db.Where(\"state = ?\", t.State) if err = db.Where(\"is_del = ?\", 0).Find(\u0026tags).Error; err != nil { return nil, err } return tags, nil } func (t Tag) Create(db *gorm.DB) error { return db.Create(\u0026t).Error } func (t Tag) Update(db *gorm.DB, values interface{}) error { if err := db.Model(t).Where(\"id = ? AND is_del = ?\", t.ID, 0).Updates(values).Error; err != nil { return err } return nil } func (t Tag) Delete(db *gorm.DB) error { return db.Where(\"id = ? AND is_del = ?\", t.Model.ID, 0).Delete(\u0026t).Error } func (t Tag) Get(db *gorm.DB) (Tag, error) { var tag Tag err := db.Where(\"id = ? AND is_del = ? AND state = ?\", t.ID, 0, t.State).First(\u0026tag).Error if err != nil \u0026\u0026 err != gorm.ErrRecordNotFound { return tag, err } return tag, nil } Model: specify the model which runs DB operation Where: set filter, accept map, struct, string as conditions Offset: specify the numbers of records to skip before return the records Limit: specify the number of records to be retrieved ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:1:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#taggo"},{"categories":["Document"],"content":"3.2 model callback for public fields like CreatedOn, ModifiedOn, we can set model callback to handle them. In Gorm, supported callback methods are as follow : register a new callback delete current callback replace current callback register order of callback In the project we are using “replace current callback”. Open model.go under internal/model, then write callback code for model Tip callback method should be placed after NewDBEngine model.go func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { ... db.SingularTable(true) db.Callback().Create().Replace(\"gorm:update_time_stamp\", updateTimeStampForCreateCallback) db.Callback().Update().Replace(\"gorm:update_time_stamp\", updateTimeStampForUpdateCallback) db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } func updateTimestampForCreateCallback(scope *gorm.Scope) { if !scope.HasError() { nowTime := time.Now().Unix() if createTimeField, ok := scope.FieldByName(\"CreatedOn\"); ok { if createTimeField.IsBlank { _ = createTimeField.Set(nowTime) } } if modifyTimeField, ok := scope.FieldByName(\"ModifiedOn\"); ok { if modifyTimeField.IsBlank { _ = modifyTimeField.Set(nowTime) } } } } func updateTimeStampForUpdateCallback(scope *gorm.Scope) { if _, ok := scope.Get(\"gorm.update_column\"); !ok { _ = scope.SetColumn(\"ModifiedOn\", time.Now().Unix()) } } func deleteCallback(scope *gorm.Scope) { if !scope.HasError() { var extraOption string if str, ok := scope.Get(\"gorm:delete_option\"); ok { extraOption = fmt.Sprint(str) } deletedOnField, hasDeletedOnField := scope.FieldByName(\"DeletedOn\") isDelField, hasIsDelField := scope.FieldByName(\"IsDel\") if !scope.Search.Unscoped \u0026\u0026 hasDeletedOnField \u0026\u0026 hasIsDelField { now := time.Now().Unix() scope.Raw(fmt.Sprintf( \"UPDATE %v SET %v=%v,%v=%v%v%v\", scope.QuotedTableName(), scope.Quote(deletedOnField.DBName), scope.AddToVars(now), scope.Quote(isDelField.DBName), scope.AddToVars(1), addExtraSpaceIfExist(scope.CombinedConditionSql()), addExtraSpaceIfExist(extraOption), )).Exec() } else { scope.Raw(fmt.Sprintf( \"DELETE FROM %v%v%v\", scope.QuotedTableName(), addExtraSpaceIfExist(scope.CombinedConditionSql()), addExtraSpaceIfExist(extraOption), )).Exec() } } } func addExtraSpaceIfExist(str string) string { if str != \"\" { return \" \" + str } return \"\" } scope.FieldByName is used to find gorm.Field with field name or db name scope.Get(“gorm:update_column”) is used to get setting by name ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#32-model-callback"},{"categories":["Document"],"content":"3.2 model callback for public fields like CreatedOn, ModifiedOn, we can set model callback to handle them. In Gorm, supported callback methods are as follow : register a new callback delete current callback replace current callback register order of callback In the project we are using “replace current callback”. Open model.go under internal/model, then write callback code for model Tip callback method should be placed after NewDBEngine model.go func NewDBEngine(databaseSetting *setting.DatabaseSettingS) (*gorm.DB, error) { ... db.SingularTable(true) db.Callback().Create().Replace(\"gorm:update_time_stamp\", updateTimeStampForCreateCallback) db.Callback().Update().Replace(\"gorm:update_time_stamp\", updateTimeStampForUpdateCallback) db.Callback().Delete().Replace(\"gorm:delete\", deleteCallback) db.DB().SetMaxIdleConns(databaseSetting.MaxIdleConns) db.DB().SetMaxOpenConns(databaseSetting.MaxOpenConns) return db, nil } func updateTimestampForCreateCallback(scope *gorm.Scope) { if !scope.HasError() { nowTime := time.Now().Unix() if createTimeField, ok := scope.FieldByName(\"CreatedOn\"); ok { if createTimeField.IsBlank { _ = createTimeField.Set(nowTime) } } if modifyTimeField, ok := scope.FieldByName(\"ModifiedOn\"); ok { if modifyTimeField.IsBlank { _ = modifyTimeField.Set(nowTime) } } } } func updateTimeStampForUpdateCallback(scope *gorm.Scope) { if _, ok := scope.Get(\"gorm.update_column\"); !ok { _ = scope.SetColumn(\"ModifiedOn\", time.Now().Unix()) } } func deleteCallback(scope *gorm.Scope) { if !scope.HasError() { var extraOption string if str, ok := scope.Get(\"gorm:delete_option\"); ok { extraOption = fmt.Sprint(str) } deletedOnField, hasDeletedOnField := scope.FieldByName(\"DeletedOn\") isDelField, hasIsDelField := scope.FieldByName(\"IsDel\") if !scope.Search.Unscoped \u0026\u0026 hasDeletedOnField \u0026\u0026 hasIsDelField { now := time.Now().Unix() scope.Raw(fmt.Sprintf( \"UPDATE %v SET %v=%v,%v=%v%v%v\", scope.QuotedTableName(), scope.Quote(deletedOnField.DBName), scope.AddToVars(now), scope.Quote(isDelField.DBName), scope.AddToVars(1), addExtraSpaceIfExist(scope.CombinedConditionSql()), addExtraSpaceIfExist(extraOption), )).Exec() } else { scope.Raw(fmt.Sprintf( \"DELETE FROM %v%v%v\", scope.QuotedTableName(), addExtraSpaceIfExist(scope.CombinedConditionSql()), addExtraSpaceIfExist(extraOption), )).Exec() } } } func addExtraSpaceIfExist(str string) string { if str != \"\" { return \" \" + str } return \"\" } scope.FieldByName is used to find gorm.Field with field name or db name scope.Get(“gorm:update_column”) is used to get setting by name ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#modelgo"},{"categories":["Document"],"content":"3.3 Build dao method create dao.go under internal/dao, and write following code type Dao struct { engine *gorm.DB } func New(engine *gorm.DB) *Dao { return \u0026Dao{engine: engine} } create tag.go at the same directory, which doing dao operation for tag model func (d *Dao) CountTag(name string, state uint8) (int, error) { tag := model.Tag{Name: name, State: state} return tag.Count{d.engine} } func (d *Dao) GetTagList(name string, state uint8, page, pageSize int) ([]*model.Tag, error) { tag := model.Tag{Name: name, State: state} pageOffset := app.GetPageOffset(page, pageSize) return tag.List(d.engine, pageOffset, pageSize) } func (d *Dao) CreateTag(name string, state uint8, createdBy string) error { tag := model.Tag{ Name: name, State: state, Model: \u0026model.Model{CreatedBy: createdBy}, } return tag.Create(d.engine) func (d *Dao) UpdateTag(id uint32, name string, state uint8, modifiedBy string) error { tag := model.Tag { Name: name, State: state, Model: \u0026model.Model{ID: id, ModifiedBy: modifiedBy}, } return tag.Update(d.engine) } func (d *Dao) DeleteTag(id uint32) error { tag := model.Tag{Model: \u0026model.Model{ID: id}} return tag.Delete(d.engine) } code above encapsulate data accessing object in dao, and precess needed field ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#33-build-dao-method"},{"categories":["Document"],"content":"3.4 Service method create service.go under internal/service type Service struct { ctx context.Context dao *dao.Dao } func New(ctx context.Context) Service { svc := Service{ctx: ctx} svc.dao = dao.New(global.DBEngine) return svc } create tag.go under same directory, precess business logic of tag module type CountTagRequest struct { Name string `form:\"name\" binding:\"max=100\"` State uint8 `form:\"state,default=1\" binding:\"oneof=0 1\"` } type TagListRequest struct { Name string `form:\"name\" binding:\"max=100\"` State uint8 `form:\"state,default=1\" binding:\"oneof=0 1\"` } type CreateTagRequest struct { Name string `form:\"name\" binding:\"required,min=3,max=100\"` CreatedBy string `form:\"created_by\" binding:\"required,min=3,max=100\"` State uint8 `form:\"state,default=1\" binding:\"oneof=0 1\"` } type UpdateTagRequest struct { ID uint32 `form:\"id\" binding:\"required,gte=1\"` Name string `form:\"name\" binding:\"min=3,max=100\"` State uint8 `form:\"state\" binding:\"oneof=0 1\"` ModifiedBy string `form:\"modified_by\" binding:\"required,min=3,max=100\"` } type DeleteTagRequest struct { ID uint32 `form:\"id\" binding:\"required,gte=1\"` } func (svc *Service) CountTag(param *CountTagRequest) (int, error) { return svc.dao.CountTag(param.Name, param.State) } func (svc *Service) GetTagList(param *TagListRequest, pager *app.Pager) ([]*model.Tag, error) { return svc.dao.GetTagList(param.Name, param.State, pager.Page, pager.PageSize) } func (svc *Service) CreateTag(param *CreateTagRequest) error { return svc.dao.CreateTag(param.Name, param.State, param.CreatedBy) } func (svc *Service) UpdateTag(param *UpdateTagRequest) error { return svc.dao.UpdateTag(param.ID, param.Name, param.State, param.ModifiedBy) } func (svc *Service) DeleteTag(param *DeleteTagRequest) error { return svc.dao.DeleteTag(param.ID) } we define Request struct as the reference for the interface entry. Other than that, we do some simple encapsulation in service ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:4:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#34-service-method"},{"categories":["Document"],"content":"3.5 New err code create module_code.go under pkg/errcode for tag module ErrorGetTagListFail = NewError(20010001, \"获取标签列表失败\") ErrorCreateTagFail = NewError(20010002, \"创建标签失败\") ErrorUpdateTagFail = NewError(20010003, \"更新标签失败\") ErrorDeleteTagFail = NewError(20010004, \"删除标签失败\") ErrorCountTagFail = NewError(20010005, \"统计标签失败\") ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:5:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#35-new-err-code"},{"categories":["Document"],"content":"3.6 New router method open tag.go under internal/routers/api/v1 func (t Tag) List(c *gin.Context) { param := service.TagListRequest{} response := app.NewResponse(c) valid, errs := app.BindAndValid(c, \u0026param) if !valid { global.Logger.Errorf(\"app.BindAndValid errs: %v\", errs) response.ToErrorResponse(errcode.InvalidParams.WithDetails(errs.Errors()...)) return } svc := service.New(c.Request.Context()) pager := app.Pager{Page: app.GetPage(c), PageSize: app.GetPageSize(c)} totalRows, err := svc.CountTag(\u0026service.CountTagRequest{Name: param.Name, State: param.State}) if err != nil { global.Logger.Errorf(\"svc.CountTag err: %v\", err) response.ToErrorResponse(errcode.ErrorCountTagFail) return } tags, err := svc.GetTagList(\u0026param, \u0026pager) if err != nil { global.Logger.Errorf(\"svc.GetTagList err: %v\", err) response.ToErrorResponse(errcode.ErrorGetTagListFail) return } response.ToResponseList(tags, totalRows) return } func (t Tag) Create(c *gin.Context) { param := service.CreateTagRequest{} response := app.NewResponse(c) valid, errs := app.BindAndValid(c, \u0026param) if !valid { global.Logger.Errorf(\"app.BindAndValid errs: %v\", errs) response.ToErrorResponse(errcode.InvalidParams.WithDetails(errs.Errors()...)) return } svc := service.New(c.Request.Context()) err := svc.CreateTag(\u0026param) if err != nil { global.Logger.Errorf(\"svc.CreateTag err: %v\", err) response.ToErrorResponse(errcode.ErrorCreateTagFail) return } response.ToResponse(gin.H{}) return } func (t Tag) Update(c *gin.Context) { param := service.UpdateTagRequest{ID: convert.StrTo(c.Param(\"id\")).MustUInt32()} response := app.NewResponse(c) valid, errs := app.BindAndValid(c, \u0026param) if !valid { global.Logger.Errorf(\"app.BindAndValid errs: %v\", errs) response.ToErrorResponse(errcode.InvalidParams.WithDetails(errs.Errors()...)) return } svc := service.New(c.Request.Context()) err := svc.UpdateTag(\u0026param) if err != nil { global.Logger.Errorf(\"svc.UpdateTag err: %v\", err) response.ToErrorResponse(errcode.ErrorUpdateTagFail) return } response.ToResponse(gin.H{}) return } func (t Tag) Delete(c *gin.Context) { param := service.DeleteTagRequest{ID: convert.StrTo(c.Param(\"id\")).MustUInt32()} response := app.NewResponse(c) valid, errs := app.BindAndValid(c, \u0026param) if !valid { global.Logger.Errorf(\"app.BindAndValid errs: %v\", errs) response.ToErrorResponse(errcode.InvalidParams.WithDetails(errs.Errors()...)) return } svc := service.New(c.Request.Context()) err := svc.DeleteTag(\u0026param) if err != nil { global.Logger.Errorf(\"svc.DeleteTag err: %v\", err) response.ToErrorResponse(errcode.ErrorDeleteTagFail) return } response.ToResponse(gin.H{}) return } ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:6:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#36-new-router-method"},{"categories":["Document"],"content":"3.7 Problem After we test the interface we need to make sure data in database get modified properly. We find that when we call updateTag interface, we want to change status from tag which id is 1 into 0, but status in database remains to be 1, additionally SQL query don’t contain conditioning for status field. terminal output SQL is as follow: UPDATE`blog_tag`SET`id`=1,`modified_by`='eddycjy',`modified_on`=xxxxxWHERE`blog_tag`.`id`=1 this is because GORM won’t do changes to field which value is 0, as it’s hard to tell 0 is the value we want to pass or 0 stand for not changing. To solve this problem, we need to modify Update method of tag.go under internal/model func (t Tag) Update(db *gorm.DB, values interface{}) error { if err := db.Model(t).Updates(values).Where(\"id = ? AND is_del = ?\",t.ID).Error; err != nil { return err } return err } then modify UpdateTag method in *tag.go under internal/dao func (d *Dao) UpdateTag(id uint32, name string, state uint8, modifiedBy string) error { tag := model.Tag { Model: \u0026model.Model { ID: id, }, } values := map[string]interface{} { \"state\": state, \"modified_by\": modifiedBy, } if name != \"\" { values[\"name\"] = name } return tag.Update(d.engine, values) } ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:7:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#37-problem"},{"categories":["Document"],"content":"3.8 Summary Go interface development is kinda similar to JAVA, SQL operation is done in model layer, then being encapsulated and initialize some field value like pageOffset by DAO layer, Service layer majorly encapsulate business logic, router method is all about parameter verification and binding, processing operation, serializing result set. ","date":"2021-12-31","objectID":"/posts/gin-tutorial-3/:8:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-3","uri":"/posts/gin-tutorial-3/#38-summary"},{"categories":["Documentation"],"content":"In this chapter, we majorly deal with project structure, interface, router. ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:0:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#"},{"categories":["Documentation"],"content":"1. Structure blog-service ├── configs ├── docs ├── global ├── internal │ ├── dao │ ├── middleware │ ├── model │ ├── routers │ └── service ├── pkg ├── storage ├── scripts └── third_party ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:1:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#1-structure"},{"categories":["Documentation"],"content":"2. Model The attributes of objects have in common should create an individual model to store . ├── internal/ │ └── model/ │ ├──model.go │ ├──tag.go │ ├──article.go │ └──article_tag.go and in each table model should contain the *Model tag.go type Tag struct { *Model Name string `json:\"name\"` State uint8 `json:\"state\"` } func (t Tag) TableName() string { return \"blog_tag\" } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#2-model"},{"categories":["Documentation"],"content":"2. Model The attributes of objects have in common should create an individual model to store . ├── internal/ │ └── model/ │ ├──model.go │ ├──tag.go │ ├──article.go │ └──article_tag.go and in each table model should contain the *Model tag.go type Tag struct { *Model Name string `json:\"name\"` State uint8 `json:\"state\"` } func (t Tag) TableName() string { return \"blog_tag\" } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:2:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#taggo"},{"categories":["Documentation"],"content":"3. Router ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:0","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#3-router"},{"categories":["Documentation"],"content":"3.1 router management decide the business api and declare the create method in internal/routers router.go func NewRouter() *gin.Engine { r := gin.New() r.Use(gin.Logger()) r.Use(gin.Recovery()) apiv1 := r.Group(\"/api/v1\") { apiv1.POST(\"/tags\") apiv1.DELETE(\"/tags/:id\") apiv1.PUT(\"/tags/:id\") apiv1.PATCH(\"/tags/:id/state\") apiv1.GET(\"/tags\") apiv1.POST(\"/articles\") apiv1.DELETE(\"/articles/:id\") apiv1.PUT(\"/articles/:id\") apiv1.PATCH(\"/articles/:id/state\") apiv1.GET(\"/articles/:id\") apiv1.GET(\"/articles\") } return r } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:1","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#31-router-management"},{"categories":["Documentation"],"content":"3.2 Router handler api handler should be stored inside the internal/routers/api, dir name is the api’s version tag.go type Tag struct {} func NewTag() Tag { return Tag{} } func (t Tag) Get(c *gin.Context) {} func (t Tag) List(c *gin.Context) {} func (t Tag) Create(c *gin.Context) {} func (t Tag) Update(c *gin.Context) {} func (t Tag) Delete(c *gin.Context) {} ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#32-router-handler"},{"categories":["Documentation"],"content":"3.2 Router handler api handler should be stored inside the internal/routers/api, dir name is the api’s version tag.go type Tag struct {} func NewTag() Tag { return Tag{} } func (t Tag) Get(c *gin.Context) {} func (t Tag) List(c *gin.Context) {} func (t Tag) Create(c *gin.Context) {} func (t Tag) Update(c *gin.Context) {} func (t Tag) Delete(c *gin.Context) {} ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:2","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#taggo-1"},{"categories":["Documentation"],"content":"3.3 Boot access modify main.go, set parameters like TCP Endpoint, Readtime of http.Server main.go func main() { router := routers.NewRouter() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 \u003c\u003c 20, } s.ListenAndServe() } ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#33-boot-access"},{"categories":["Documentation"],"content":"3.3 Boot access modify main.go, set parameters like TCP Endpoint, Readtime of http.Server main.go func main() { router := routers.NewRouter() s := \u0026http.Server{ Addr: \":8080\", Handler: router, ReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second, MaxHeaderBytes: 1 ","date":"2021-03-10","objectID":"/posts/gin-tutorial-1/:3:3","series":["gin-tutorial"],"tags":["Go","Backend"],"title":"Gin-Tutorial-1","uri":"/posts/gin-tutorial-1/#maingo"},{"categories":["Problem-Set"],"content":"1. ssh can’t connect to github Description: error kex_exchange_identification: Connection closed by remote host poped up when pushing to github. Got the same error message by running ssh -T git@github.com Solution: Use another VPN ","date":"2020-10-17","objectID":"/posts/problem-set/git/:1:0","series":null,"tags":["Git"],"title":"Git Problem Set","uri":"/posts/problem-set/git/#1-ssh-cant-connect-to-github"},{"categories":["Problem-Set"],"content":"2. fast-forward when pushing to remote Solution: merge or fetch before push. Tip git push -f ... also works, but the repercussion might be irreversible and perilous ","date":"2020-10-17","objectID":"/posts/problem-set/git/:2:0","series":null,"tags":["Git"],"title":"Git Problem Set","uri":"/posts/problem-set/git/#2-fast-forward-when-pushing-to-remote"},{"categories":["Problem-Set"],"content":"1.make command execute correctly, but the site can’t be reached for some reasons. Description: By using telnet command, we can know certain port’s status. As a result, the 1313 port of wsl is running by hugo, but that of windows is closed. Apparently, solve the disconnection between wsl and windows gonna handle this problem. ref： https://logi.im/script/achieving-access-to-files-and-resources-on-the-network-between-win10-and-wsl2.html https://www.cnblogs.com/hapjin/p/5367429.html For programs listen to 0.0.0.0 in wsl2, win10 can be accessed directly through localhost:port. Therefore we have to set bind address equal to 0.0.0.0 on hugo hugo server --bind=0.0.0.0 --port=1313 --minify --theme book Reason: The default address of localhost is Loopback address 127.0.0.1. It can only be accessed by local machine. So if we want to access wsl2 address from other consoles, we have to replace localhost in /etc/hosts. By adding new rule to hugo Makefile, type make win to create local blog on wsl2 that can be accessed on other machines wsl win windows: hugo server --bind=0.0.0.0 --port=1313 --minify --theme book ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:1:0","series":null,"tags":["Linux","WSL"],"title":"WSL2 Problem Set","uri":"/posts/problem-set/wsl/#1_make_-command-execute-correctly-but-the-site-cant-be-reached-for-some-reasons"},{"categories":["Problem-Set"],"content":"2.Port depolyed at 0:0:0:0 can’t be accessed from Windows. Description: Almost the same with #problem 1, but Spring is running at 0:0:0:0. Spring-boot’s port can’t be browsed through Windows browser. ref: https://github.com/microsoft/WSL/discussions/2471 Using wsl --shutdown solved this problem, and we can also handle this by replacing localhost into the ip address of etho from ip addr(for some unknown reasons, the speed is way faster than using localhost) ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:2:0","series":null,"tags":["Linux","WSL"],"title":"WSL2 Problem Set","uri":"/posts/problem-set/wsl/#2port-depolyed-at-0000-cant-be-accessed-from-windows"},{"categories":["Problem-Set"],"content":"3.The connection from Windows to MySQL in WSL2 failed Description: Connect to MySQL by setting ip as localhost(already set the bind_address=0.0.0.0), but it ended up failure. ref: https://github.com/microsoft/WSL/issues/4150 https://stackoverflow.com/questions/61002681/connecting-to-wsl2-server-via-local-network It seems like Ubuntu host is virtually connected to windows host, and it’s netted by the Windows computer. To change that, we gonna forward the wsl2 port to windows, by using netsh interface portproxy add v4tov4 listenport=\u003cport-to-listen\u003e listenaddress=0.0.0.0 connectport=\u003cport-to-forward\u003e connectaddress=\u003cforward-to-this-IP-address\u003e Since then, there’s another problem as the ip address of wsl2 is dynamic, it will change as you reboot. To improve this method, we should run a script every time we start our computer that does: Get Ip Address of WSL2 machine Remove previous port forwarding rules Add port Forwarding rules Remove previously added firewall rules Add new Firewall Rules $remoteport = bash.exe -c \"ifconfig eth0 | grep 'inet '\" $found = $remoteport -match '\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}'; if( $found ){ $remoteport = $matches[0]; } else{ echo \"The Script Exited, the ip address of WSL 2 cannot be found\"; exit; } #[Ports] #All the ports you want to forward separated by coma $ports=@(80,443,10000,3000,5000); #[Static ip] #You can change the addr to your ip config to listen to a specific address $addr='0.0.0.0'; $ports_a = $ports -join \",\"; #Remove Firewall Exception Rules iex \"Remove-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' \"; #adding Exception Rules for inbound and outbound Rules iex \"New-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' -Direction Outbound -LocalPort $ports_a -Action Allow -Protocol TCP\"; iex \"New-NetFireWallRule -DisplayName 'WSL 2 Firewall Unlock' -Direction Inbound -LocalPort $ports_a -Action Allow -Protocol TCP\"; for( $i = 0; $i -lt $ports.length; $i++ ){ $port = $ports[$i]; iex \"netsh interface portproxy delete v4tov4 listenport=$port listenaddress=$addr\"; iex \"netsh interface portproxy add v4tov4 listenport=$port listenaddress=$addr connectport=$port connectaddress=$remoteport\"; } The script must run under highest privilege. Use task scheduler to automatically start powershell and add argument as -ExecutionPolicy Bypass c:\\scripts\\wslbridge.ps1. Tip Navicat should change the ip to 127.0.0.1 instead of localhost. ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:3:0","series":null,"tags":["Linux","WSL"],"title":"WSL2 Problem Set","uri":"/posts/problem-set/wsl/#3the-connection-from-windows-to-mysql-in-wsl2-failed"},{"categories":["Problem-Set"],"content":"4.Temporary failure resolving ‘security.ubuntu.com’ Description: get output Temporary failure resolving 'security.ubuntu.com' after doing sudo apt update ref: https://stackoverflow.com/questions/60269422/windows10-wsl2-ubuntu-debian-no-network create file /etc/wsl.conf write [network] generateResolvConf = false change nameserver xxx.xx.x.x into nameserver 8.8.8.8 ","date":"2020-09-23","objectID":"/posts/problem-set/wsl/:4:0","series":null,"tags":["Linux","WSL"],"title":"WSL2 Problem Set","uri":"/posts/problem-set/wsl/#4temporary-failure-resolving-securityubuntucom"},{"categories":null,"content":"Who Am I My name is Shawn, a Computer Science Student from Chengdu/China. Hobby: Music, Food, Anime Favorite Music: J-Pop, Rock, Jazz, Blues Favorite Band/Musician: ヨルシカ Favorite Anime: 天元突破グレンラガン Currently learning guitar🎸(Electric) ","date":"2019-08-02","objectID":"/about/:1:0","series":null,"tags":null,"title":"About me","uri":"/about/#who-am-i"},{"categories":null,"content":"Skill Backend Development(Golang) Frontend Development(Vue) Tools(k8s, Docker, MySQL, Postgre, Git, Github Action) ","date":"2019-08-02","objectID":"/about/:2:0","series":null,"tags":null,"title":"About me","uri":"/about/#skill"},{"categories":null,"content":" You are not connected to the Internet, only cached pages will be available. ","date":"0001-01-01","objectID":"/offline/:0:0","series":null,"tags":null,"title":"Offline","uri":"/offline/#"}]